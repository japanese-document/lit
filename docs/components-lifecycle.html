<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="twitter:card" content="summary" />
    <meta property="og:url" content="https://japanese-document.github.io/lit/components-lifecycle.html" />
    <meta property="og:title" content="ライフサイクル" />
    <meta property="og:description" content="LitコンポーネントはWeb標準であるcustom elementsのライフサイクルメソッドを使っています。更にLitはリアクティブプロパティが変更された時にDOMにそれを反映するリアクティブアップデートサイクルを追加しています。custom elementsのライフサイクルLitコンポーネントはcustom elementsです。そして、custom elementsのライフサイクルメソッドを継承しています。custom elementsのライフサイクルの詳しい情報はUsing the lifecycle callbacksを見てください。コンポーネントでcustom elementsのライ" />
    <meta property="og:image" content="https://avatars2.githubusercontent.com/u/42838312?s=400" />
    <meta name="theme-color" content="#f1f7fe" />
    <meta name="description" content="LitコンポーネントはWeb標準であるcustom elementsのライフサイクルメソッドを使っています。更にLitはリアクティブプロパティが変更された時にDOMにそれを反映するリアクティブアップデートサイクルを追加しています。custom elementsのライフサイクルLitコンポーネントはcustom elementsです。そして、custom elementsのライフサイクルメソッドを継承しています。custom elementsのライフサイクルの詳しい情報はUsing the lifecycle callbacksを見てください。コンポーネントでcustom elementsのライ" />
    <title>ライフサイクル</title>
    <link rel="stylesheet" href="/lit/app.css?v=001" type="text/css"  media="all" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L9VVC74WWF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-L9VVC74WWF');
    </script>
  </head>
  <body class="container">
    <div class="left-side">
    <div class="index-menu">
      <details open="">
        <summary>コンポーネント</summary>
        <p><a href="https://japanese-document.github.io/lit/components-defining.html">定義</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-rendering.html">レンダリング</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-properties.html">リアクティブプロパティ</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-styles.html">スタイル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-lifecycle.html">ライフサイクル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-shadow-dom.html">Shadow DOM</a></p>
      </details>
      <details open="">
        <summary>テンプレート</summary>
        <p><a href="https://japanese-document.github.io/lit/templates-expressions.html">Expressions</a></p>
      </details>
      <details open="">
        <summary>API</summary>
        <p><a href="https://japanese-document.github.io/lit/api-LitElement.html">LitElement</a></p>
        <p><a href="https://japanese-document.github.io/lit/api-templates.html">テンプレート</a></p>
      </details>
    </div></div>
    <main class="main markdown-body">
      <h1 id="ライフサイクル"><a href="#ライフサイクル">ライフサイクル</a></h1>
<p>LitコンポーネントはWeb標準であるcustom elementsのライフサイクルメソッドを使っています。
更にLitはリアクティブプロパティが変更された時にDOMにそれを反映するリアクティブアップデートサイクルを追加しています。</p>
<h2 id="custom_elementsのライフサイクル"><a href="#custom_elementsのライフサイクル">custom elementsのライフサイクル</a></h2>
<p>Litコンポーネントはcustom elementsです。そして、custom elementsのライフサイクルメソッドを継承しています。
custom elementsのライフサイクルの詳しい情報は<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks">Using the lifecycle callbacks</a>を見てください。</p>
<p>コンポーネントでcustom elementsのライフサイクルメソッドをオーバーライドする場合、
Litが正常に動作するために、そのメソッド内でそれに該当する<code>super</code>のメソッド(例: <code>super.connectedCallback()</code>)を実行しなければなりません。</p>
<h3 id="constructor()"><a href="#constructor()">constructor()</a></h3>
<p>custom elements(Litコンポーネント)が生成される時に実行されます。
既にDOMにcustom elementsが存在していてcustom elements(Litコンポーネント)の定義がロードされた時(アップグレードされた時)も実行されます。</p>
<h4 id="Litの動作"><a href="#Litの動作">Litの動作</a></h4>
<p><code>requestUpdate()</code>メソッドを実行して非同期更新をリクエストします。
そうすることでLitコンポーネントにアップグレードされた時にすぐに更新されます。</p>
<p>要素の既存のプロパティを保存します。
これによって要素にセットされたプロパティの値が保持されます。そして、コンポーネントのデフォルトの値をそれで上書きすることができます。</p>
<h4 id="ユースケース"><a href="#ユースケース">ユースケース</a></h4>
<p>最初の<a class="Link" href="#リアクティブアップデートサイクル">更新</a>の前に1回だけ実行する必要がある初期化処理を実行です。
例えば、デコレータを使わない場合、<a class="Link" href="https://japanese-document.github.io/lit/components-properties.html#パブリックプロパティとインターナルステート"><code>static properties</code>クラスフィールドを使います</a>。
その場合、constructor()内でデフォルトの値をセットします。</p>
<pre><code class="language-js">constructor() {
  super();
  this.foo = 'foo';
  this.bar = 'bar';
}
</code></pre>
<h3 id="connectedCallback()"><a href="#connectedCallback()">connectedCallback()</a></h3>
<p>コンポーネントがdocumentに接続された(追加された)時に実行されます。</p>
<h4 id="Litの動作"><a href="#Litの動作">Litの動作</a></h4>
<p>要素がdocumentに接続された後、Litはアップデートサイクルの一番目の処理を開始します。
レンダリングをする前にLitは<code>renderRoot</code>(通常は<code>shadowRoot</code>)が生成済みか確認します。</p>
<p>1回でも要素がドキュメントに接続すると、コンポーネントの更新は接続状態に関係なく進みます。</p>
<h4 id="ユースケース"><a href="#ユースケース">ユースケース</a></h4>
<p><code>connectedCallback()</code>には要素がdocumentに接続した時のみ実行したい処理を記述します。
それの最も一般的なケースは要素の外部のNodeにイベントリスナを追加することです。例えばkeydownイベントハンドラをwindowに追加することです。
通常、要素がdocumentから切断された時は<code>connectedCallback()</code>で加えた何かを元に戻す必要があります。例えば、メモリーリークを防止するためにwindowに登録したイベントリスナを削除することです。</p>
<pre><code class="language-js">connectedCallback() {
  super.connectedCallback()
  addEventListener('keydown', this._handleKeydown);
}
</code></pre>
<h3 id="disconnectedCallback()"><a href="#disconnectedCallback()">disconnectedCallback()</a></h3>
<p>コンポーネントがdocumentのDOMツリーから削除されたら実行されます。</p>
<h4 id="Litの動作"><a href="#Litの動作">Litの動作</a></h4>
<p><a class="Link" href="#リアクティブアップデートサイクル">リアクティブアップデートサイクル</a>を一時停止します。 要素が接続されたら再開します。</p>
<h4 id="ユースケース"><a href="#ユースケース">ユースケース</a></h4>
<p>このコールバックが実行されることは要素が今後使われないかもしれないことを示しています。
ガベージコレクションで要素を解放するために、
<code>disconnectedCallback()</code>では要素への参照を保持している物(例えば要素を参照している外部のNodeに加えられたイベントリスナ)がないか確認する必要があります。
例えば、<code>window</code>に追加されたkeydownイベントハンドラのように要素の外部のNodeからイベントリスナを削除します。
要素がDOMツリー内を移動したりキャッシュされることによって、非接続になった後に再度接続することがあります。
このため正常に動作するためにそのような参照もしくはイベントリスナは<code>connectedCallback()</code>で再度セットする必要があります。</p>
<pre><code class="language-js">disconnectedCallback() {
  super.disconnectedCallback()
  window.removeEventListener('keydown', this._handleKeydown);
}
</code></pre>
<p>コンポーネント内のDOMに加えられた(テンプレート内で宣言的に加えられた物も含む)イベントリスナを削除する必要はありません。
外部のNodeに追加されたイベントリスナとは違って、それはコンポーネントのガベージコレクションを妨げません。</p>
<h3 id="attributeChangedCallback()"><a href="#attributeChangedCallback()">attributeChangedCallback()</a></h3>
<p>要素の<a class="Link" href="https://japanese-document.github.io/lit/api-LitElement.html#static_observedAttributes__Array">observedAttributes</a>が1つでも変更された時に実行されます。</p>
<h4 id="Litの動作"><a href="#Litの動作">Litの動作</a></h4>
<p>Litはこのコールバックを属性の変更をリアクティブプロパティに同期することに使います。
それは属性に値がセットされるとそれに対応するプロパティに値がセットされます。
Litは自動的に要素の<code>observedAttributes</code>とコンポーネントのリアクティブプロパティがそれぞれ対応するようにします。</p>
<h4 id="ユースケース"><a href="#ユースケース">ユースケース</a></h4>
<p>このコールバックを実装する機会はほどんどありません。</p>
<h3 id="adoptedCallback()"><a href="#adoptedCallback()">adoptedCallback()</a></h3>
<p>コンポーネントが別のdocumentに移動したときに実行されます。</p>
<p><code>adoptedCallback</code>はPolyfillにはないことに注意してください。</p>
<h4 id="Litの動作"><a href="#Litの動作">Litの動作</a></h4>
<p>デフォルトではLitはこのコールバックで何もしません。</p>
<h4 id="ユースケース"><a href="#ユースケース">ユースケース</a></h4>
<p>このコールバックはdocumentを移動した時に要素の動作を変更するような高度なユースケースに使われます。</p>
<h2 id="リアクティブアップデートサイクル"><a href="#リアクティブアップデートサイクル">リアクティブアップデートサイクル</a></h2>
<p>LitコンポーネントはWeb標準のcustom elementsのライフサイクルに加えてリアクティブアップデートサイクルを用意しています。</p>
<p>リアクティブアップデートサイクルはリアクティブプロパティが変更された時もしくは<code>requestUpdate()</code>メソッドが明示的に実行された時に発動します。
Litは更新を非同期で行います。そして、プロパティの変更の反映はまとめて行われます。
つまり、更新をリクエストした後に複数のプロパティが変更された場合、更新が始まる前だったら、すべての変更は同じ更新で反映されます。</p>
<p>更新はmicrotaskのタイミング(ブラウザが次のフレームを画面に描画する前)で行われます。
microtaskの説明は<a class="Link" href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Jake Archibaldの記事</a>を見てください。</p>
<p>端的に言うとリアクティブプロパティは下記のようになります。</p>
<ol>
<li>1つ以上のプロパティが変更された時もしくは<code>requestUpdate()</code>が実行された時、更新がスケジュールされます。</li>
<li>次のフレームが描画される前に更新が実行されます。<ol>
<li>コンポーネントのプロパティが要素の属性に反映されます。</li>
<li>コンポーネント内のDOMを更新するためにrenderメソッドが実行されます。</li>
</ol>
</li>
<li>更新が完了します。そして、<code>updateComplete</code>のPromiseが<code>resolve</code>されます。</li>
</ol>
<p>詳細は下記のようになります。</p>
<p><strong>更新前</strong></p>
<p><img alt="update-1" src="/lit/images/components-update-1.jpg"></p>
<p><img alt="update-2" src="/lit/images/components-update-2.jpg"></p>
<p><strong>更新</strong></p>
<p><img alt="update-3" src="/lit/images/components-update-3.jpg"></p>
<p><strong>更新後</strong></p>
<p><img alt="update-4" src="/lit/images/components-update-4.jpg"></p>
<h3 id="changedProperties"><a href="#changedProperties">changedProperties</a></h3>
<p>多くのリアクティブアップデートサイクルのメソッドは変更済みのプロパティを<code>Map</code>に格納した引数(<code>changedProperties</code>)として受け取ります。
<code>Map</code>のキーはプロパティ名です。そして、その値は1つ前のプロパティの値です。
現行のプロパティの値は<code>this.property</code>もしくは<code>this[property]</code>で取得することができます。</p>
<h4 id="changedPropertiesの型"><a href="#changedPropertiesの型">changedPropertiesの型</a></h4>
<p>TypeScriptで<code>changedProperties</code>に対して厳格な型チェックをしたい場合は<code>PropertyValues&lt;this&gt;</code>を使います。これは各プロパティ名に対して正確な型を推論します。</p>
<pre><code class="language-ts">import {LitElement, html, PropertyValues} from 'lit';
...
  shouldUpdate(changedProperties: PropertyValues&lt;this&gt;) {
    ...
  }
</code></pre>
<p>厳格な型が必要ないなら(プロパティ名だけチェックして1つ前の値はチェックしない)、<code>Map&lt;string, any&gt;</code>のような緩い型を使うこともできます。</p>
<p><code>PropertyValues&lt;this&gt;</code>は<code>protected</code>と<code>private</code>なプロパティを認識しません。
<code>protected</code>と<code>private</code>なプロパティをチェックしたい場合は<code>Map&lt;string, any&gt;</code>のような緩い型を使います。</p>
<h4 id="更新中のプロパティの変更"><a href="#更新中のプロパティの変更">更新中のプロパティの変更</a></h4>
<p>更新中(<code>render()</code>メソッド完了まで)にプロパティを変更すると<code>changedProperties</code>は変更されますが、新たなアップデートサイクルを発動しません。
<code>render()</code>メソッドの後(例: <code>updated()</code>内)でプロパティを変更した場合は新たなアップデートサイクルを発動します。
そして、変更されたプロパティは新たな<code>changedProperties</code>に反映されて次のアップデートサイクルで使われます。</p>
<h3 id="更新の発動"><a href="#更新の発動">更新の発動</a></h3>
<p>リアクティブプロパティが変更される、もしくは<code>requestUpdate()</code>を実行すると更新が発動されます。
更新は非同期で実行されるので、
更新が実行される前に生じた変更はまとめて1回の更新で反映されます。</p>
<h4 id="hasChanged()"><a href="#hasChanged()">hasChanged()</a></h4>
<p>リアクティブプロパティに値がセットされた時に実行されます。
デフォルトでは<code>hasChanged()</code>は<code>!==</code>で比較します。そして、<code>true</code>を返した場合、更新がスケジュールされます。
詳しくは<a class="Link" href="https://japanese-document.github.io/lit/components-properties.html#hasChanged"><code>hasChanged()</code></a>を見てください。</p>
<h4 id="requestUpdate()"><a href="#requestUpdate()">requestUpdate()</a></h4>
<p><code>requestUpdate()</code>を実行すると明示的に更新をスケジュールすることができます。
これはプロパティの変更によらずに要素を更新してレンダリングしたい場合に使います。
例えば、タイマーコンポーネントは1秒ごとに<code>requestUpdate()</code>を実行します。</p>
<pre><code class="language-js">connectedCallback() {
  super.connectedCallback();
  this._timerInterval = setInterval(() =&gt; this.requestUpdate(), 1000);
}

disconnectedCallback() {
  super.disconnectedCallback();
  clearInterval(this._timerInterval);
}
</code></pre>
<p>変更されたプロパティのリストは<code>changedProperties</code> Mapに格納されます。それはこの後に実行されるライフサイクルメソッドに渡されます。
そのMapのキーはプロパティ名です。そして、その値はひとつ前のプロパティの値です。</p>
<p><code>requestUpdate()</code>を実行する時にプロパティ名とその1つ前の値を渡すことでそれを<code>changedProperties</code> Mapに格納することができます。
これはカスタムゲッタやセッタを実装する際に使います。
カスタムゲッタやセッタに関する詳しい情報は<a class="Link" href="https://japanese-document.github.io/lit/components-properties.html">リアクティブプロパティ</a>を見てください。</p>
<pre><code class="language-js">  this.requestUpdate('state', this._previousState);
</code></pre>
<h3 id="更新の実行"><a href="#更新の実行">更新の実行</a></h3>
<p><code>performUpdate()</code>が更新を実行します。このメソッド内で複数のライフサイクルが実行されます。</p>
<p>これは更新処理中にプロパティの値の計算を可能にするために、
通常はコンポーネントの更新中に更新を発動する変更は新しい更新をスケジュールしません。
更新中に変更されたプロパティは<code>changedProperties</code> Mapに反映されます。だから、その後のライフサイクルメソッドは変更を反映した処理を行うことができます。</p>
<h4 id="shouldUpdate()"><a href="#shouldUpdate()">shouldUpdate()</a></h4>
<p>更新を実行するかどうか判断するために実行されます。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>引数</td>
<td><code>changedProperties</code>: 変更されたプロパティ名をキーに持ち、その1つ前の値を値に持つ<code>Map</code></td>
</tr>
<tr>
<td>更新は発動するか</td>
<td>いいえ、このメソッド内でのプロパティの変更は要素の更新を発動しません。</td>
</tr>
<tr>
<td>superを実行する必要があるか</td>
<td>いいえ</td>
</tr>
<tr>
<td>サーバで実行されるか</td>
<td>いいえ</td>
</tr>
</tbody></table>
<p><code>shouldUpdate()</code>が<code>true</code>を返した場合(これがデフォルト)、更新が実行されます。
<code>false</code>を返した場合は残りのアップデートサイクルは実行されませんが<code>updateComplete</code>のPromiseはresolveされます。</p>
<p><code>shouldUpdate()</code>を実装すれば特定のプロパティが変更されたときのみ更新が発動するようにすることができます。
現在の値と1つ前の値との比較は<code>changedProperties</code>を使います。</p>
<pre><code class="language-ts">shouldUpdate(changedProperties: Map&lt;string, any&gt;) {
  // prop1が変更された場合のみ更新されます。
  return changedProperties.has('prop1'); 
}
</code></pre>
<h4 id="willUpdate()"><a href="#willUpdate()">willUpdate()</a></h4>
<p><code>update()</code>を実行する前に実行されます。更新で使用する値を生成する用途に使います。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>引数</td>
<td><code>changedProperties</code>: 変更されたプロパティ名をキーに持ち、その1つ前の値を値に持つ<code>Map</code></td>
</tr>
<tr>
<td>更新は発動するか</td>
<td>いいえ、このメソッド内でのプロパティの変更は要素の更新を発動しません。</td>
</tr>
<tr>
<td>superを実行する必要があるか</td>
<td>いいえ</td>
</tr>
<tr>
<td>サーバで実行されるか</td>
<td>はい</td>
</tr>
</tbody></table>
<p>残りの更新プロセスで使われるプロパティの値を他のプロパティを使って生成する処理を<code>willUpdate()</code>に実装します。</p>
<pre><code class="language-ts">willUpdate(changedProperties: PropertyValues&lt;this&gt;) {
  // 必要な時だけ高コストな処理を実行するために変更されたプロパティを確認します。
  if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
    this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
  }
}

render() {
  return html`SHA: ${this.sha}`;
}
</code></pre>
<h4 id="update()"><a href="#update()">update()</a></h4>
<p>コンポーネントのDOMを更新するために実行されます。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>引数</td>
<td><code>changedProperties</code>: 変更されたプロパティ名をキーに持ち、その1つ前の値を値に持つ<code>Map</code></td>
</tr>
<tr>
<td>更新は発動するか</td>
<td>いいえ、このメソッド内でのプロパティの変更は要素の更新を発動しません。</td>
</tr>
<tr>
<td>superを実行する必要があるか</td>
<td>はい、実行しない場合、要素の属性とテンプレートは更新されません。</td>
</tr>
<tr>
<td>サーバで実行されるか</td>
<td>いいえ</td>
</tr>
</tbody></table>
<p>プロパティの値を要素の属性に反映します。そして、<code>render()</code>でコンポーネント内のDOMを更新します。</p>
<p>通常、このメソッドを実装することはありません。</p>
<h4 id="render()"><a href="#render()">render()</a></h4>
<p><code>render()</code>は<code>update()</code>内で実行されます。
<code>render()</code>はコンポーネントのDOMとしてレンダリングできる値(例: <code>TemplateResult</code>)を返すように実装する必要があります。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>引数</td>
<td>なし</td>
</tr>
<tr>
<td>更新は発動するか</td>
<td>いいえ、このメソッド内でのプロパティの変更は要素の更新を発動しません。</td>
</tr>
<tr>
<td>superを実行する必要があるか</td>
<td>いいえ</td>
</tr>
<tr>
<td>サーバで実行されるか</td>
<td>はい</td>
</tr>
</tbody></table>
<p><code>render()</code>は引数を取りません。
通常はコンポーネントのプロパティを使います。
詳しくは<a class="Link" href="https://japanese-document.github.io/lit/components-rendering.html">レンダリング</a>を見てください。</p>
<pre><code class="language-js">render() {
  const header = `&lt;header&gt;${this.header}&lt;/header&gt;`;
  const content = `&lt;section&gt;${this.content}&lt;/section&gt;`;
  return html`${header}${content}`;
}
</code></pre>
<h3 id="更新の完了"><a href="#更新の完了">更新の完了</a></h3>
<p>変更をコンポーネントのDOMにレンダリングするために<code>update()</code>を実行した後、以下のメソッドを使ってコンポーネントのDOMを操作することができます。</p>
<h4 id="firstUpdated()"><a href="#firstUpdated()">firstUpdated()</a></h4>
<p>初回のコンポーネントのDOMの更新後、<a class="Link" href="#updated"><code>updated()</code></a>が実行される直前に実行されます。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>引数</td>
<td><code>changedProperties</code>: 変更されたプロパティ名をキーに持ち、その1つ前の値を値に持つ<code>Map</code></td>
</tr>
<tr>
<td>更新は発動するか</td>
<td>はい、このメソッド内でプロパティが変更されると新たにアップデートサイクルがスケジュールされます。</td>
</tr>
<tr>
<td>superを実行する必要があるか</td>
<td>いいえ</td>
</tr>
<tr>
<td>サーバで実行されるか</td>
<td>いいえ</td>
</tr>
</tbody></table>
<p><code>firstUpdated()</code>には初回にコンポーネントのDOMが生成された後に１回だけ実行したい処理を実装します。
例えば、下記のようにレンダリングされた要素にfocusを当てる処理や、要素に<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver">ResizeObserver</a>もしくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver">IntersectionObserver</a>を加える処理です。</p>
<pre><code class="language-js">firstUpdated() {
  this.renderRoot.getElementById('my-text-area').focus();
}
</code></pre>
<h4 id="updated()"><a href="#updated()">updated()</a></h4>
<p>コンポーネントの更新が終了して要素のDOMの更新とレンダリングがされる毎に実行されます。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>引数</td>
<td><code>changedProperties</code>: 変更されたプロパティ名をキーに持ち、その1つ前の値を値に持つ<code>Map</code></td>
</tr>
<tr>
<td>更新は発動するか</td>
<td>はい、このメソッド内でプロパティが変更されると新たにアップデートサイクルがスケジュールされます。</td>
</tr>
<tr>
<td>superを実行する必要があるか</td>
<td>いいえ</td>
</tr>
<tr>
<td>サーバで実行されるか</td>
<td>いいえ</td>
</tr>
</tbody></table>
<p>更新の後に要素を使う処理は<code>updated()</code>に実装します。
例えば、アニメーションを実行するコードでは要素の大きさを計測する必要があるかもしれません。</p>
<pre><code class="language-ts">updated(changedProperties: Map&lt;string, any&gt;) {
  if (changedProperties.has('collapsed')) {
    this._measureDOM();
  }
}
</code></pre>
<h4 id="updateComplete"><a href="#updateComplete">updateComplete</a></h4>
<p><code>updateComplete</code>はPromiseです。これは更新が終了した時に解決されます。
<code>updateComplete</code>は更新の終了を待つために使います。
解決した値は要素の更新が終了したかどうかを示すbooleanです。
それが<code>true</code>ならアップデートサイクルが終了した後に待機している更新はありません。</p>
<p>要素の更新は、その子要素の更新を引き起こす場合があります。
デフォルトではその要素の更新が完了すると<code>updateComplete</code> Promiseは解決しますが、その要素の子要素の更新が完了するまで待ちません。
この動作は<a class="Link" href="#getUpdateComplete()"><code>getUpdateComplete()</code></a>をオーバーライドすることで変更することができます。</p>
<p>下記はコンポーネントの更新が完了することが必要な処理の例です。</p>
<ol>
<li><p><strong>テスト</strong>
テストを書く時、コンポーネントのDOMをassertする前に<code>updateComplete</code> Promiseを<code>await</code>します。
しかし、assertする段階でコンポーネントの子孫要素全体の更新が完了している必要がある場合、通常は<code>requestAnimationFrame</code>コールバックを使うことを推奨します。
理由はLitのデフォルトのスケジューリングがブラウザのmicrotaskキューを使っているからです。microtaskキューはanimation frameの前に空になります。
これによって、ページ内で待機しているすべてのLitの更新が<code>requestAnimationFrame</code>コールバックより前で完了します。</p>
</li>
<li><p><strong>測定</strong> 
目的のレイアウトにするためにコンポーネントのDOMサイズを測定する必要があるかもしれません。
レイアウトはJavaScriptを使わずにCSSのみで実装する方が好ましいですが、CSSの制限のために使わざるを得ない場合があります。
LitやReactiveElementのコンポーネントを測定する際は、ステートを変更した後かつ測定する前に<code>updateComplete</code>をawaitすることで解決できるかもしれません。
この方法で充分かもしれませんが、<code>updateComplete</code>は子孫要素全体の更新が完了を待ちません。
だから、レイアウトが変更された時により確実に測定する処理を実行する方法として<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver"><code>ResizeObserver</code></a>を使う方法を推奨します。</p>
</li>
<li><p><strong>イベント</strong>
レンダリングを完了した後、コンポーネントからイベントをdispatchすることを推奨します。
そうするとイベントリスナはコンポーネントが完全にレンダリングされたかどうか知ることができます。
下記のようにイベントをdispatchする前に<code>updateComplete</code> Promiseをawaitします。</p>
<pre><code class="language-js">async _loginClickHandler() {
  this.loggedIn = true;
  // loggedInステートがレンダリングされてDOMに反映されるまで待ちます。
  await this.updateComplete;
  this.dispatchEvent(new Event('login'));
}
</code></pre>
</li>
</ol>
<p>アップデートサイクル中に未処理のエラーがある場合、<code>updateComplete</code> Promiseはrejectします。
詳しくは<a class="Link" href="#アップデートサイクル中のエラーを取り扱う">アップデートサイクル中のエラーを取り扱う</a>を見てください。</p>
<h3 id="アップデートサイクル中のエラーを取り扱う"><a href="#アップデートサイクル中のエラーを取り扱う">アップデートサイクル中のエラーを取り扱う</a></h3>
<p><code>render()</code>や<code>update()</code>のようなライフサイクルメソッド内でcatchされない例外が発生は<code>updateComplete</code> Promiseのrejectを引き起します。
ライフサイクルメソッド内のコードで例外がthrowされる可能性がある場合、それを<code>try</code>/<code>catch</code>ステートメントで囲むと良いでしょう。</p>
<p><code>updateComplete</code> Promiseをawaitする時はそれを<code>try</code>/<code>catch</code>ステートメントで囲むと良いでしょう。</p>
<pre><code class="language-js">try {
  await this.updateComplete;
} catch (e) {
  /* エラーを取り扱う */
}
</code></pre>
<p>予期しない所でコードがthrowする場合があります。
すべてのthrowに対応するために、<code>window.onunhandledrejection</code>にハンドラをセットします。
例えば再現することが難しい問題を切り分けるためにバックエンドサービスにエラーレポートを送信するために使います。</p>
<pre><code class="language-js">window.onunhandledrejection = function(e) {
  /* エラーを取り扱う */
}
</code></pre>
<h3 id="その他のライフサイクルメソッドを変更する"><a href="#その他のライフサイクルメソッドを変更する">その他のライフサイクルメソッドを変更する</a></h3>
<p>このセクションでは余り変更することがないライフサイクルメソッドを紹介します。</p>
<h4 id="scheduleUpdate()"><a href="#scheduleUpdate()">scheduleUpdate()</a></h4>
<p><code>scheduleUpdate()</code>をオーバーライドすると更新するタイミングを変更することができます。
<code>scheduleUpdate()</code>は更新が実行される直前に実行されます。デフォルトではすぐに<code>performUpdate()</code>を実行します。
<code>scheduleUpdate()</code>をオーバーライドすることで更新の実行を延期することができます。
これをすることによって更新がメインのレンダリング/イベントスレッドをブロックすることを防ぎます。
下記のコードは次のフレームの描画の後に更新をスケジュールします。これで更新処理が高コストな場合、<a class="Link" href="https://developer.mozilla.org/en-US/docs/Glossary/Jank">Jank</a>を削減することができます。</p>
<pre><code class="language-ts">protected override async scheduleUpdate(): Promise&lt;void&gt; {
  await new Promise((resolve) =&gt; setTimeout(resolve));
  super.scheduleUpdate();
}
</code></pre>
<p><code>scheduleUpdate()</code>をオーバーライドする場合、上記のように保留中の更新を実行するために<code>super.scheduleUpdate()</code>を実行する必要があります。</p>
<h4 id="performUpdate()"><a href="#performUpdate()">performUpdate()</a></h4>
<p><code>performUpdate()</code>には<code>shouldUpdate()</code>、<code>update()</code>、<code>updated()</code>を実行してリアクティブアップデートサイクルを実行する処理を実装します。</p>
<p><code>performUpdate()</code>を実行すると保留中の更新をすぐに実行することができます。
通常これを使うことはありませんが、同期的に更新を行いたい場合に使います。
(保留中の更新がない場合、<code>requestUpdate()</code>を実行して<code>performUpdate()</code>が実行されることで同期的な更新を強制することができます。)</p>
<h4 id="hasUpdated"><a href="#hasUpdated">hasUpdated</a></h4>
<p>1回以上コンポーネントが更新されている場合、<code>hasUpdated</code>プロパティはtrueを返します。
<code>hasUpdated</code>はライフサイクルメソッド内でコンポーネントが1回も更新されていない時に実行したい処理を実行したい場合に役立ちます。</p>
<h4 id="getUpdateComplete()"><a href="#getUpdateComplete()">getUpdateComplete()</a></h4>
<p><code>updateComplete</code> Promiseの完了条件を変更するには<code>getUpdateComplete()</code>をオーバーライドします。
例えば、下記のように子要素の更新をawaitすることに利用します。
最初に<code>super.getUpdateComplete()</code>をawaitして、次に処理を追加します。</p>
<pre><code class="language-js">class MyElement extends LitElement {
  async getUpdateComplete() {
    await super.getUpdateComplete();
    await this._myChild.updateComplete;
  }
}
</code></pre>
<h2 id="外部ライフサイクルフック(コントローラとデコレータ)"><a href="#外部ライフサイクルフック(コントローラとデコレータ)">外部ライフサイクルフック(コントローラとデコレータ)</a></h2>
<p>コンポーネントクラスにライフサイクルメソッドを実装することに加えて、<a class="Link" href="https://lit.dev/docs/components/decorators/">デコレータ</a>のようにクラス外部のコードを使ってコンポーネントのライフサイクルを変更することができます。</p>
<p>Litは外部コードをリアクティブアップデートサイクルに統合するために2つの仕組みを提供します。
それは<code>static addInitializer()</code>と<code>addController()</code>です。</p>
<h4 id="static_addInitializer()"><a href="#static_addInitializer()">static addInitializer()</a></h4>
<p><code>addInitializer()</code>を使うとLitコンポーネントクラスの定義時に、そのクラスインスタンスが生成される時に実行されるコードを登録することができます。</p>
<p>カスタムデコレータを実装する時によく使います。
デコレータはクラスの定義される時に実行されます。そして、フィールドやメソッドの定義を置き換えることができます。
インスタンスが生成される時にそれらをする必要がある場合は<code>addInitializer()</code>を実行する必要があります。
通常はこれを利用してデコレータでコンポーネントのライフサイクルをフックするために<a class="Link" href="https://lit.dev/docs/composition/controllers/">リアクティブコントローラ</a>を使います。</p>
<pre><code class="language-ts">// TypeScriptのデコレータ
const myDecorator = (proto: ReactiveElement, key: string) =&gt; {
  const ctor = proto.constructor as typeof ReactiveElement;

  ctor.addInitializer((instance: ReactiveElement) =&gt; {
    // 要素の生成時に実行します。
    new MyController(instance);
  });
};
</code></pre>
<p>下記のように、フィールドにデコレータをセットすると各インスタンス毎にコントローラを追加するイニシャライザが実行されます。</p>
<pre><code class="language-ts">class MyElement extends LitElement {
  @myDecorator foo;
}
</code></pre>
<p>イニシャライザはコンストラクタ毎に格納されます。
イニシャライザをサブクラスに加えてもスーパークラスには加えられません。
イニシャライザはコンストラクタで実行されるので、
イニシャライザはクラスの階層順(スーパークラスからサブクラスの順番)で実行されます。</p>
<h4 id="addController()"><a href="#addController()">addController()</a></h4>
<p>コンポーネントがコントローラのライフサイクルコールバックを実行するために<code>addController()</code>はリアクティブコントローラをLitコンポーネントに追加します。
詳しくは<a class="Link" href="https://lit.dev/docs/composition/controllers/">リアクティブコントローラ</a>を見てください。</p>
<h4 id="removeController()"><a href="#removeController()">removeController()</a></h4>
<p><code>removeController()</code>はリアクティブコントローラを削除します。そして、コンポーネントからリアクティブライフサイクルコールバックを受け取らないようにします。</p>
<h2 id="サーバーサイドリアクティブアップデートサイクル"><a href="#サーバーサイドリアクティブアップデートサイクル">サーバーサイドリアクティブアップデートサイクル</a></h2>
<p>Litの<a class="Link" href="https://lit.dev/docs/ssr/overview/">サーバーサイドレンダリングパッケージ</a>は現在開発中なので下記の情報は変更される可能性があります。</p>
<p>Litをサーバでレンダリングする時はすべてのアップデートサイクルが実行されるわけではありません。
次のメソッドはサーバで実行されます。</p>
<p><img alt="update-server" src="/lit/images/components-update-server.jpg"></p>
<hr>
<h2 id="License"><a href="#License">License</a></h2>
<h3 id="Japanese_part"><a href="#Japanese_part">Japanese part</a></h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by-nc/4.0/legalcode">Creative Commons Attribution-NonCommercial 4.0 International Public License</a></p>
<p>Copyright (c) 2022 38elements</p>
<h3 id="Other"><a href="#Other">Other</a></h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by/3.0/deed.en">Creative Commons Attribution 3.0 Unported</a></p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>BSD 3-Clause License</p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ol>
<li><p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p>
</li>
<li><p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p>
</li>
<li><p>Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.</p>
</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </main>
    <div class="right-side"><div class="header-list"><p class="h1"><a href="#ライフサイクル">ライフサイクル</a></p>
<p class="h2"><a href="#custom_elementsのライフサイクル">custom elementsのライフサイクル</a></p>
<p class="h3"><a href="#constructor()">constructor()</a></p>
<p class="h4"><a href="#Litの動作">Litの動作</a></p>
<p class="h4"><a href="#ユースケース">ユースケース</a></p>
<p class="h3"><a href="#connectedCallback()">connectedCallback()</a></p>
<p class="h4"><a href="#Litの動作">Litの動作</a></p>
<p class="h4"><a href="#ユースケース">ユースケース</a></p>
<p class="h3"><a href="#disconnectedCallback()">disconnectedCallback()</a></p>
<p class="h4"><a href="#Litの動作">Litの動作</a></p>
<p class="h4"><a href="#ユースケース">ユースケース</a></p>
<p class="h3"><a href="#attributeChangedCallback()">attributeChangedCallback()</a></p>
<p class="h4"><a href="#Litの動作">Litの動作</a></p>
<p class="h4"><a href="#ユースケース">ユースケース</a></p>
<p class="h3"><a href="#adoptedCallback()">adoptedCallback()</a></p>
<p class="h4"><a href="#Litの動作">Litの動作</a></p>
<p class="h4"><a href="#ユースケース">ユースケース</a></p>
<p class="h2"><a href="#リアクティブアップデートサイクル">リアクティブアップデートサイクル</a></p>
<p class="h3"><a href="#changedProperties">changedProperties</a></p>
<p class="h4"><a href="#changedPropertiesの型">changedPropertiesの型</a></p>
<p class="h4"><a href="#更新中のプロパティの変更">更新中のプロパティの変更</a></p>
<p class="h3"><a href="#更新の発動">更新の発動</a></p>
<p class="h4"><a href="#hasChanged()">hasChanged()</a></p>
<p class="h4"><a href="#requestUpdate()">requestUpdate()</a></p>
<p class="h3"><a href="#更新の実行">更新の実行</a></p>
<p class="h4"><a href="#shouldUpdate()">shouldUpdate()</a></p>
<p class="h4"><a href="#willUpdate()">willUpdate()</a></p>
<p class="h4"><a href="#update()">update()</a></p>
<p class="h4"><a href="#render()">render()</a></p>
<p class="h3"><a href="#更新の完了">更新の完了</a></p>
<p class="h4"><a href="#firstUpdated()">firstUpdated()</a></p>
<p class="h4"><a href="#updated()">updated()</a></p>
<p class="h4"><a href="#updateComplete">updateComplete</a></p>
<p class="h3"><a href="#アップデートサイクル中のエラーを取り扱う">アップデートサイクル中のエラーを取り扱う</a></p>
<p class="h3"><a href="#その他のライフサイクルメソッドを変更する">その他のライフサイクルメソッドを変更する</a></p>
<p class="h4"><a href="#scheduleUpdate()">scheduleUpdate()</a></p>
<p class="h4"><a href="#performUpdate()">performUpdate()</a></p>
<p class="h4"><a href="#hasUpdated">hasUpdated</a></p>
<p class="h4"><a href="#getUpdateComplete()">getUpdateComplete()</a></p>
<p class="h2"><a href="#外部ライフサイクルフック(コントローラとデコレータ)">外部ライフサイクルフック(コントローラとデコレータ)</a></p>
<p class="h4"><a href="#static_addInitializer()">static addInitializer()</a></p>
<p class="h4"><a href="#addController()">addController()</a></p>
<p class="h4"><a href="#removeController()">removeController()</a></p>
<p class="h2"><a href="#サーバーサイドリアクティブアップデートサイクル">サーバーサイドリアクティブアップデートサイクル</a></p>
<p class="h2"><a href="#License">License</a></p>
<p class="h3"><a href="#Japanese_part">Japanese part</a></p>
<p class="h3"><a href="#Other">Other</a></p></div></div>
    <footer class="footer markdown-body">
      <a href="/lit">Top</a>
    </footer>
  </body>
</html>