<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="twitter:card" content="summary" />
    <meta property="og:url" content="https://japanese-document.github.io/lit/data-context.html" />
    <meta property="og:title" content="コンテキスト" />
    <meta property="og:description" content="コンテキスト(Context)を使うと各コンポーネントのプロパティに値を手動でセットすることなしに、コンポーネントのサブツリー全体にデータを行き渡らせることができます。データはコンテキスト上で利用することができます。だから、データのプロバイダとコンシューマの間にある要素はコンテキストを効力する必要はありません。Litのコンテキストは@lit/contextで実装されています。npm i @lit/contextコンテキストはアプリのデータストア、ユーザのデータ、UIテーマのようなデータを多数のコンポーネントに流通することに使用します。また、普通のDOMの子要素にデータを渡す必要があるような、デ" />
    <meta property="og:image" content="https://avatars2.githubusercontent.com/u/42838312?s=400" />
    <meta name="theme-color" content="#f1f7fe" />
    <meta name="description" content="コンテキスト(Context)を使うと各コンポーネントのプロパティに値を手動でセットすることなしに、コンポーネントのサブツリー全体にデータを行き渡らせることができます。データはコンテキスト上で利用することができます。だから、データのプロバイダとコンシューマの間にある要素はコンテキストを効力する必要はありません。Litのコンテキストは@lit/contextで実装されています。npm i @lit/contextコンテキストはアプリのデータストア、ユーザのデータ、UIテーマのようなデータを多数のコンポーネントに流通することに使用します。また、普通のDOMの子要素にデータを渡す必要があるような、デ" />
    <meta name="Hatena::Bookmark" content="nocomment" />
    <title>コンテキスト</title>
    <link rel="icon" type="image/png" href="/lit/images/favicon.png" />
    <link rel="stylesheet" href="/lit/app.css?v=001" type="text/css"  media="all" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L9VVC74WWF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-L9VVC74WWF');
    </script>
  </head>
  <body class="container">
    <div class="left-side">
    <nav class="index-menu">
      <details open="">
        <summary>コンポーネント</summary>
        <p><a href="https://japanese-document.github.io/lit/components-defining.html">定義</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-rendering.html">レンダリング</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-properties.html">リアクティブプロパティ</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-styles.html">スタイル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-lifecycle.html">ライフサイクル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-shadow-dom.html">Shadow DOM</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-events.html">イベント</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-decorators.html">デコレータ</a></p>
      </details>
      <details open="">
        <summary>テンプレート</summary>
        <p><a href="https://japanese-document.github.io/lit/templates-expressions.html">エクスプレッション</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-conditionals.html">条件</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-lists.html">リスト</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-directives.html">ビルトインディレクティブ</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-custom-directives.html">カスタムディレクティブ</a></p>
      </details>
      <details open="">
        <summary>組み合わせ</summary>
        <p><a href="https://japanese-document.github.io/lit/composition-component.html">コンポーネントを組み合わせる</a></p>
        <p><a href="https://japanese-document.github.io/lit/composition-controllers.html">リアクティブコントローラ</a></p>
      </details>
      <details open="">
        <summary>データ管理</summary>
        <p><a href="https://japanese-document.github.io/lit/data-context.html">コンテキスト</a></p>
        <p><a href="https://japanese-document.github.io/lit/data-tasks.html">Async Tasks</a></p>
      </details>
      <details open="">
        <summary>API</summary>
        <p><a href="https://japanese-document.github.io/lit/api-LitElement.html">LitElement</a></p>
        <p><a href="https://japanese-document.github.io/lit/api-templates.html">テンプレート</a></p>
      </details>
    </nav></div>
    <main class="main markdown-body">
      <h1 id="コンテキスト"><a class="anchor" href="#コンテキスト">#</a>コンテキスト</h1>
<p>コンテキスト(Context)を使うと各コンポーネントのプロパティに値を手動でセットすることなしに、コンポーネントのサブツリー全体にデータを行き渡らせることができます。
データはコンテキスト上で利用することができます。だから、データのプロバイダとコンシューマの間にある要素はコンテキストを効力する必要はありません。</p>
<p>Litのコンテキストは<code>@lit/context</code>で実装されています。</p>
<pre><code class="language-bash">npm i @lit/context
</code></pre>
<p>コンテキストはアプリのデータストア、ユーザのデータ、UIテーマのようなデータを多数のコンポーネントに流通することに使用します。
また、普通のDOMの子要素にデータを渡す必要があるような、データを渡すことができない場合にも使用します。</p>
<p>LitのコンテキストはReactのコンテキストやAngularのDIシステムにとても似ています。
しかし、Litのコンテキストは動的なDOM構造の変化に対応しています。また、他のweb componentを使ったライブラリやフレームワークや素のJavaScriptでも利用することができます。</p>
<h2 id="例"><a class="anchor" href="#例">#</a>例</h2>
<p>コンテキストはコンテキストオブジェクト、プロバイダ(provider)、コンシューマ(consumer)で構成されています。
コンテキストオブジェクトを使ってデータを流通させます。</p>
<ul>
<li>コンテキストの定義(<code>logger-context.ts</code>)</li>
</ul>
<pre><code class="language-ts">import {createContext} from '@lit/context';
import type {Logger} from 'my-logging-library';
export type {Logger} from 'my-logging-library';
export const loggerContext = createContext&lt;Logger&gt;('logger');
</code></pre>
<ul>
<li>プロバイダ</li>
</ul>
<pre><code class="language-ts">import {LitElement, property, html} from 'lit';
import {provide} from '@lit/context';

import {Logger} from 'my-logging-library';
import {loggerContext} from './logger-context.js';

@customElement('my-app')
class MyApp extends LitElement {

  @provide({context: loggerContext})
  logger = new Logger();

  render() {
    return html`...`;
  }
}
</code></pre>
<ul>
<li>コンシューマ</li>
</ul>
<pre><code class="language-ts">import {LitElement, property} from 'lit';
import {consume} from '@lit/context';

import {type Logger, loggerContext} from './logger-context.js';

export class MyElement extends LitElement {

  @consume({context: loggerContext})
  @property({attribute: false})
  public logger?: Logger;

  private doThing() {
    this.logger?.log('A thing was done');
  }
}
</code></pre>
<h2 id="キーコンセプト"><a class="anchor" href="#キーコンセプト">#</a>キーコンセプト</h2>
<h3 id="コンテキストプロトコル"><a class="anchor" href="#コンテキストプロトコル">#</a>コンテキストプロトコル</h3>
<p>LitのコンテキストはW3Cの<a class="Link" href="https://www.w3.org/community/webcomponents/">Web Components Community Group</a>によって作成された<a class="Link" href="https://github.com/webcomponents-cg/community-protocols/blob/main/proposals/context.md">Context Community Protocol</a>に基づいています。</p>
<p>このプロトコルに従うとライブラリ関係なく要素(もしくは要素ではないコードでも)にコンテキストを介してデータを共有することができます。
このコンテキストプロトコルを経由して、Litの要素はLitで作られていないコンシューマでもデータを供給できます。また、その逆も可能です。</p>
<p>コンテキストプロトコルはDOMイベントをベースにしています。
コンシューマは必要なコンテキストオブジェクトを取得するために<code>context-request</code>イベントを送出します。
コンシューマより上位の要素は<code>context-request</code>イベントをリッスンすることができます。そして、コンテキストオブジェクトに対応するデータを供給します。</p>
<p><code>@lit/context</code>はこのイベントベースのプロトコルを実装しています。リアクティブコントローラやデコレータを使ってこれを使います。</p>
<h3 id="コンテキストオブジェクト"><a class="anchor" href="#コンテキストオブジェクト">#</a>コンテキストオブジェクト</h3>
<p>コンテキストの値はコンテキストオブジェクトに紐づいています。
コンテキストオブジェクトとコンテキストの値は<code>Map</code>のキーと値に似ています。</p>
<h3 id="プロバイダ"><a class="anchor" href="#プロバイダ">#</a>プロバイダ</h3>
<p>一般的にプロバイダは要素です。(イベントハンドラでも可能です。)プロバイダはコンテキストオブジェクトに対応したデータを提供します。</p>
<h3 id="コンシューマ"><a class="anchor" href="#コンシューマ">#</a>コンシューマ</h3>
<p>コンシューマはコンテキストオブジェクトに対応するデータをリクエストします。</p>
<h3 id="サブスクリプション"><a class="anchor" href="#サブスクリプション">#</a>サブスクリプション</h3>
<p>コンシューマがコンテキストのデータをリクエストする時、プロバイダにコンテキストのデータをサブスクライブ(subscribe)することを通知することができます。
プロバイダに新しい値をセットすると、コンシューマに通知されて自動的に更新されます。</p>
<h2 id="使い方"><a class="anchor" href="#使い方">#</a>使い方</h2>
<h3 id="コンテキストを定義する"><a class="anchor" href="#コンテキストを定義する">#</a>コンテキストを定義する</h3>
<p>コンテキストはデータリクエストに対応したコンテキストオブジェクトを持つ必要があります。
コンテキストオブジェクトはそのデータのidと型を表します。</p>
<p>コンテキストオブジェクトは下記のように<code>createContext()</code>を使って生成します。</p>
<pre><code class="language-ts">export const myContext = createContext(Symbol('my-context'));
</code></pre>
<h4 id="コンテキストの型チェック"><a class="anchor" href="#コンテキストの型チェック">#</a>コンテキストの型チェック</h4>
<p><code>createContext()</code>は任意の値を受け取って、受け取った値をそのまま返します。
TypeScriptでは、戻り値を<code>Context</code>型のオブジェクトにキャストします。
そのオブジェクトはコンテクストオブジェクトとそれに対応する値の型を内包しています。</p>
<p>下記のコードには間違いがあります。
下記のコードでは、TypeScriptは<code>string</code>型は<code>Logger</code>型に割り当てることができないという警告を出すでしょう。
このチェックは現時点ではpublicフィールドのみ対象となります。</p>
<pre><code class="language-ts">const myContext = createContext&lt;Logger&gt;(Symbol('logger'));

class MyElement extends LitElement {
  @provide({context: myContext})
  name: string
}
</code></pre>
<h4 id="コンテキストの比較"><a class="anchor" href="#コンテキストの比較">#</a>コンテキストの比較</h4>
<p>プロバイダはコンテクストオブジェクトをコンテキストリクエストイベントに対応する値を取得することに使いします。
プロバイダはプロバイダに設定されたコンテキストオブジェクトとリクエストのコンテキストオブジェクトが一致した場合のみ処理を行います。
その比較は<code>===</code>で行われます。</p>
<p>これを考慮するとコンテキストオブジェクトを生成する方法は主に下記の2つです。</p>
<ol>
<li>オブジェクト(<code>{}</code>)やシンボル(<code>Symbol()</code>)などglobalに同じ値が1つのみ存在しないものを値にする。(<code>{} === {}</code>は<code>false</code>になる。)</li>
<li>文字列やグローバルシンボル(<code>Symbol.for('logger')</code>)のようにglobalに複数の同じ値が存在するものを値にする。(<code>'foo' === 'foo'</code>は<code>true</code>になる。)</li>
</ol>
<p>2つの別の<code>createContext()</code>の結果を使って同じコンテキストを参照するには、下記のように文字列のように<code>===</code>で比較すると等価になる値を渡します。</p>
<pre><code class="language-ts">// true
createContext('my-context') === createContext('my-context')
</code></pre>
<p>アプリケーション内にある2つのモジュールが同じコンテキストオブジェクトを使って意図せず異なるオブジェクトを参照する場合に注意してください。
この意図しない衝突を避けるために(<code>'logger'</code>の代わりに<code>'console-logger'</code>を使うように)ユニークな値を<code>createContext()</code>に渡した方が良いかもしれません。</p>
<p>通常、コンテキストオブジェクトの生成時に渡される値はglobalに同じ値が1つのみがベストです。
シンボル(<code>Symbol()</code>)を使うとこれが簡単にできます。</p>
<h3 id="値をセットする"><a class="anchor" href="#値をセットする">#</a>値をセットする</h3>
<p><code>@lit/context</code>にはコンテキストの値をセットする2つの方法があります。
それは<code>ContextProvider</code>コントローラと<code>@provide()</code>デコレータです。</p>
<h4 id="_provide()デコレータ"><a class="anchor" href="#_provide()デコレータ">#</a><code>@provide()</code>デコレータ</h4>
<p>デコレータが利用可能なら、<code>@provide()</code>デコレータはプロバイダに値をセットする最も簡単な方法です。
このデコレータは<code>ContextProvider</code>コントローラを生成します。</p>
<p>下記のように<code>@provide()</code>デコレータをプロパティに付与して、それにコンテキストオブジェクトを渡します。</p>
<pre><code class="language-ts">import {LitElement, html} from 'lit';
import {property} from 'lit/decorators.js';
import {provide} from '@lit/context';
import {myContext, MyData} from './my-context.js';

class MyApp extends LitElement {
  @provide({context: myContext})
  myData: MyData;
}
</code></pre>
<p><code>@property()</code>もしくは<code>@state()</code>をセットしたプロパティはリアクティブプロパティになります。
だから、そのプロパティを更新すると、プロバイダが存在する要素と同じようにコンテキストコンシューマも更新されます。</p>
<pre><code class="language-ts">  @provide({context: myContext})
  @property({attribute: false})
  myData: MyData;
</code></pre>
<p>コンテキストを取り扱うプロパティをprivateにすることはよくあります。
下記のように<code>@state()</code>を付与されたprivateなリアクティブプロパティをプロバイダにすることができます。</p>
<pre><code class="language-ts">  @provide({context: myContext})
  @state()
  private _myData: MyData;
</code></pre>
<p>コンテキストを扱うプロパティをpublicと<code>@property()</code>にすると、下記のようにテンプレートで値をセットすることができます。</p>
<pre><code class="language-ts">  html`&lt;my-provider-element .myData=${someData}&gt;`
</code></pre>
<h4 id="ContextProvider"><a class="anchor" href="#ContextProvider">#</a>ContextProvider</h4>
<p><code>ContextProvider</code>は<code>context-request</code>を取り扱うリアクティブコントローラです。</p>
<pre><code class="language-ts">import {LitElement, html} from 'lit';
import {ContextProvider} from '@lit/context';
import {myContext} from './my-context.js';

export class MyApp extends LitElement {
  private _provider = new ContextProvider(this, {context: myContext});
}
</code></pre>
<p>下記のように<code>ContextProvider</code>のコンストラクタで初期値を指定することができます。</p>
<pre><code class="language-ts">  private _provider = new ContextProvider(this, {context: myContext, initialValue: myData});
</code></pre>
<p>もしくは下記のように<code>setValue()</code>を使います。</p>
<pre><code class="language-ts">  this._provider.setValue(myData);
</code></pre>
<h3 id="コンシューマ"><a class="anchor" href="#コンシューマ">#</a>コンシューマ</h3>
<h4 id="_consume()デコレータ"><a class="anchor" href="#_consume()デコレータ">#</a><code>@consume()</code>デコレータ</h4>
<p>デコレータが利用可能なら、<code>@consume()</code>デコレータは値を取得する最も簡単な方法です。
このデコレータは<code>ContextConsumer</code>コントローラを生成します。</p>
<p>下記のように<code>@consume</code>にコンテキストオブジェクトを渡します。</p>
<pre><code class="language-ts">import {LitElement, html} from 'lit';
import {consume} from '@lit/context';
import {myContext, MyData} from './my-context.js';

class MyElement extends LitElement {
  @consume({context: myContext})
  myData: MyData;
}
</code></pre>
<p>上記の要素がdocumentに接続すると、
自動的に<code>context-request</code>イベントが発生します。
そして、その要素はプロバイダから提供された値を取得します。
その値は要素のプロパティにセットされます。
その要素の更新が発動されます。</p>
<h4 id="ContextConsumer"><a class="anchor" href="#ContextConsumer">#</a>ContextConsumer</h4>
<p><code>ContextConsumer</code>は<code>context-request</code>イベントのdispatchを取り扱うリアクティブコントローラです。
新しい値がプロバイダから提供されると、このコントローラはホストコンポーネントを更新します。
その提供された値はコントローラの<code>value</code>プロパティで使うことができます。</p>
<pre><code class="language-ts">import {LitElement, property} from 'lit';
import {ContextConsumer} from '@lit/context';
import {myContext} from './my-context.js';

export class MyElement extends LitElement {
  private _myData = new ContextConsumer(this, {context: myContext});

  render() {
    const myData = this._myData.value;
    return html`...`;
  }
}
</code></pre>
<h4 id="サブスクライブ"><a class="anchor" href="#サブスクライブ">#</a>サブスクライブ</h4>
<p>コンシューマはプロバイダに新しい値がセットされるタイミングで、コンテキストの値の更新をサブスクライブすることができます。
プロバイダはその値をサブスクライブしているすべてのコンシューマに渡します。
そして、それらのコンシューマのホストコンポーネントの更新を引き起こします。</p>
<p>サブスクライブを有効にするには、下記のように<code>@consume()</code>デコレータを設定します。</p>
<pre><code class="language-ts">  @consume({context: myContext, subscribe: true})
  myData: MyData;
</code></pre>
<p><code>@consume()</code>デコレータではなく<code>ContextConsumer</code>コントローラを使う場合は、下記のようにします。</p>
<pre><code class="language-ts">  private _myData = new ContextConsumer(this,
    {
      context: myContext,
      subscribe: true,
    }
  );
</code></pre>
<h2 id="ユースケース"><a class="anchor" href="#ユースケース">#</a>ユースケース</h2>
<h3 id="ユーザデータ、ロケール等"><a class="anchor" href="#ユーザデータ、ロケール等">#</a>ユーザデータ、ロケール等</h3>
<p>もっとも一般的なコンテキストのユースケースはページに分散しているコンポーネントにデータを提供することです。
この場合、コンポーネントを使わないとほぼすべてのコンポーネントのリアクティブプロパティにデータを流通させることが必要になるかもしれません。</p>
<h3 id="サービス"><a class="anchor" href="#サービス">#</a>サービス</h3>
<p>コンテキストはロガー(logger)、ウェブ分析、データストアのようなアプリケーション全体で使われるサービスを提供することに適しています。
これらのサービスをモジュールにしてコンポーネントのファイルにimportするよりコンテキストを使う利点は、
実行時にサービスを動的に指定することができる点やDOMツリーごとにサービスを指定できる点です。
具体的には、テストではサービスのモックを使いやすいです。また、ページ内の異なる部分(コンポーネント)に異なるサービスインスタンスを渡すことができます。</p>
<h3 id="テーマ"><a class="anchor" href="#テーマ">#</a>テーマ</h3>
<p>テーマはページ全体もしくはページのサブツリー全体に適用されるスタイルの集合です。
これはコンテキストが提供するデータの適用範囲と同じです。</p>
<p>テーマシステムを構築する1つの方法はコンテナ要素に適用する<code>Theme</code>型を定義することです。
その型はスタイル名とスタイルで構成されてるオブジェクトです。
テーマを適用したい要素はテーマオブジェクトを取得して、それからスタイル名でスタイルを取得します。
ContextProviderとContextConsumerをラップしたカスタムテーマリアクティブコントローラを作成すると、繰り返し同じコードを書く量が減るでしょう。</p>
<h3 id="HTMLベースのプラグイン"><a class="anchor" href="#HTMLベースのプラグイン">#</a>HTMLベースのプラグイン</h3>
<p>コンテキストを使うと普通の子要素にデータを渡すことができます。
親コンポーネントが普通の子要素を生成しない場合、
親コンポーネントはテンプレートのデータバインディングを通じてデータを子要素に渡すことができません。
しかし、子要素は<code>context-request</code>イベントに応答することはできます。</p>
<p>例として、下記のようないろいろな言語モードのプラグインと一緒に使われる<code>code-editor</code>要素について考えてみましょう。
コンテキストを使うことで、素のHTMLの仕組みを使って機能を追加することができます。</p>
<pre><code class="language-html">&lt;code-editor&gt;
  &lt;code-editor-javascript-mode&gt;&lt;/code-editor-javascript-mode&gt;
  &lt;code-editor-python-mode&gt;&lt;/code-editor-python-mode&gt;
&lt;/code-editor&gt;
</code></pre>
<p>上記の場合、<code>code-editor</code>はコンテキストを経由して言語モードを追加するAPIをプラグインに提供します。
そして、プラグイン要素はAPIをconsumeして自身をエディタに追加します。</p>
<h3 id="データフォーマッタ、リンクジェネレータ等"><a class="anchor" href="#データフォーマッタ、リンクジェネレータ等">#</a>データフォーマッタ、リンクジェネレータ等</h3>
<p>再利用可能なコンポーネントでもアプリケーションを固有のデータフォーマットやURLのフォーマットに対応する必要がある場合があります。
For example, a documentation viewer that renders a link to another item.
The component will not know the URL space of the application.</p>
<p>In these cases the component can depend on a context-provided function that will apply the application-specific formatting to the data or link.</p>
<h2 id="API"><a class="anchor" href="#API">#</a>API</h2>
<div class="alert alert-info">

<p>These API docs are a summary until generated API docs are available</p>
</div>

<h3 id="createContext()"><a class="anchor" href="#createContext()">#</a><code>createContext()</code></h3>
<p>Creates a typed Context object</p>
<p><strong>Import</strong>:</p>
<pre><code class="language-ts">import {createContext} from '@lit/context';
</code></pre>
<p><strong>Signature</strong>:</p>
<pre><code class="language-ts">function createContext&lt;ValueType, K = unknown&gt;(key: K): Context&lt;K, ValueType&gt;;
</code></pre>
<p>Contexts are compared with with strict equality.</p>
<p>If you want two separate <code>createContext()</code> calls to referrer to the same context, then use a key that will by equal under strict equality like a string for <code>Symbol.for()</code>:</p>
<pre><code class="language-ts">// true
createContext('my-context') === createContext('my-context')
// true
createContext(Symbol.for('my-context')) === createContext(Symbol.for('my-context'))
</code></pre>
<p>If you want a context to be unique so that it's guaranteed to not collide with other contexts, use a key that's unique under strict equality, like a <code>Symbol()</code> or object.:</p>
<pre><code class="language-ts">// false
createContext(Symbol('my-context')) === createContext(Symbol('my-context'))
// false
createContext({}) === createContext({})
</code></pre>
<p>The <code>ValueType</code> type parameter is the type of value that can be provided by this context. It's uses to provide accurate types in the other context APIs.</p>
<h3 id="_provide()"><a class="anchor" href="#_provide()">#</a><code>@provide()</code></h3>
<p>A property decorator that adds a ContextConsumer controller to the component which will try and retrieve a value for the property via the Context API.</p>
<p><strong>Import</strong>:</p>
<pre><code class="language-ts">import {provide} from '@lit/context';
</code></pre>
<p><strong>Signature</strong>:</p>
<pre><code class="language-ts">@provide({context: Context})
</code></pre>
<h3 id="_consume()"><a class="anchor" href="#_consume()">#</a><code>@consume()</code></h3>
<p>A property decorator that adds a ContextConsumer controller to the component which will retrieve a value for the property via the Context protocol.</p>
<p><strong>Import</strong>:</p>
<pre><code class="language-ts">import {consume} from '@lit/context';
</code></pre>
<p><strong>Signature</strong>:</p>
<pre><code class="language-ts">@consume({context: Context, subscribe?: boolean})
</code></pre>
<p><code>subscribe</code> is <code>false</code> by default. Set it to <code>true</code> to subscribe to updates to the context provided value.</p>
<h3 id="ContextProvider"><a class="anchor" href="#ContextProvider">#</a><code>ContextProvider</code></h3>
<p>A ReactiveController which adds context provider behavior to a custom element by listening to <code>context-request</code> events.</p>
<p><strong>Import</strong>:</p>
<pre><code class="language-ts">import {ContextProvider} from '@lit/context';
</code></pre>
<p><strong>Constructor</strong>:</p>
<pre><code class="language-ts">ContextProvider(
  host: ReactiveElement,
  options: {
    context: T,
    initialValue?: ContextType&lt;T&gt;
  }
)
</code></pre>
<p><strong>Members</strong></p>
<ul>
<li><p><code>setValue(v: T, force = false): void</code></p>
<p>  Sets the value provided, and notifies any subscribed consumers of the new value if the value changed. <code>force</code> causes a notification even if the value didn't change, which can be useful if an object had a deep property change.</p>
</li>
</ul>
<h3 id="ContextConsumer"><a class="anchor" href="#ContextConsumer">#</a><code>ContextConsumer</code></h3>
<p>A ReactiveController which adds context consuming behavior to a custom element by dispatching <code>context-request</code> events.</p>
<p><strong>Import</strong>:</p>
<pre><code class="language-ts">import {ContextConsumer} from '@lit/context';
</code></pre>
<p><strong>Constructor</strong>:</p>
<pre><code class="language-ts">ContextConsumer(
  host: HostElement,
  options: {
    context: C,
    callback?: (value: ContextType&lt;C&gt;, dispose?: () =&gt; void) =&gt; void,
    subscribe?: boolean = false
  }
)
</code></pre>
<p><strong>Members</strong></p>
<ul>
<li><p><code>value: ContextType&lt;C&gt;</code></p>
<p> The current value for the context.</p>
</li>
</ul>
<p>When the host element is connected to the document it will emit a <code>context-request</code> event with its context key. When the context request is satisfied the controller will invoke the callback, if present, and trigger a host update so it can respond to the new value.</p>
<p>It will also call the dispose method given by the provider when the host element is disconnected.</p>
<h3 id="ContextRoot"><a class="anchor" href="#ContextRoot">#</a><code>ContextRoot</code></h3>
<p>A ContextRoot can be used to gather unsatisfied context requests and re-dispatch them when new providers which satisfy matching context keys are available. This allows providers to be added to a DOM tree, or upgraded, after the consumers.</p>
<p><strong>Import</strong>:</p>
<pre><code class="language-ts">import {ContextRoot} from '@lit/context';
</code></pre>
<p><strong>Constructor</strong>:</p>
<pre><code class="language-ts">ContextRoot()
</code></pre>
<p><strong>Members</strong></p>
<ul>
<li><p><code>attach(element: HTMLElement): void</code></p>
<p>  Attaches the ContextRoot to this element and starts listening to <code>context-request</code> events.</p>
</li>
<li><p><code>detach(element: HTMLElement): void</code></p>
<p>  Detaches the ContextRoot from this element, stops listening to <code>context-request</code> events.</p>
</li>
</ul>
<h3 id="ContextRequestEvent"><a class="anchor" href="#ContextRequestEvent">#</a><code>ContextRequestEvent</code></h3>
<p>The event fired by consumers to request a context value. The API and behavior of this event is specified by the <a class="Link" href="https://github.com/webcomponents-cg/community-protocols/blob/main/proposals/context.md">Context Protocol</a>.</p>
<p><strong>Import</strong>:</p>
<pre><code class="language-ts">import {ContextRequestEvent} from '@lit/context';
</code></pre>
<p>The <code>context-request</code> bubbles and is composed.</p>
<p><strong>Members</strong></p>
<ul>
<li><p><code>readonly context: C</code></p>
<p>  The context object this event is requesting a value for</p>
</li>
<li><p><code>readonly callback: ContextCallback&lt;ContextType&lt;C&gt;&gt;</code></p>
<p>  The function to call to provide a context value</p>
</li>
<li><p><code>readonly subscribe?: boolean</code></p>
<p>  Whether the consumers wants to subscribe to new context values</p>
</li>
</ul>
<h3 id="ContextCallback"><a class="anchor" href="#ContextCallback">#</a><code>ContextCallback</code></h3>
<p>A callback which is provided by a context requester and is called with the value satisfying the request.</p>
<p>This callback can be called multiple times by context providers as the requested value is changed.</p>
<p><strong>Import</strong>:</p>
<pre><code class="language-ts">import {type ContextCallback} from '@lit/context';
</code></pre>
<p><strong>Signature</strong>:</p>
<pre><code class="language-ts">type ContextCallback&lt;ValueType&gt; = (
  value: ValueType,
  unsubscribe?: () =&gt; void
) =&gt; void;
</code></pre>
<hr>
<h2 id="License"><a class="anchor" href="#License">#</a>License</h2>
<h3 id="Japanese_part"><a class="anchor" href="#Japanese_part">#</a>Japanese part</h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by-nc/4.0/legalcode">Creative Commons Attribution-NonCommercial 4.0 International Public License</a></p>
<p>Copyright (c) 2022 38elements</p>
<h3 id="Other"><a class="anchor" href="#Other">#</a>Other</h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by/3.0/deed.en">Creative Commons Attribution 3.0 Unported</a></p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>BSD 3-Clause License</p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ol>
<li><p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p>
</li>
<li><p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p>
</li>
<li><p>Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.</p>
</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </main>
    <div class="right-side"><nav class="header-list"><p class="h1"><a href="#コンテキスト">コンテキスト</a></p>
<p class="h2"><a href="#例">例</a></p>
<p class="h2"><a href="#キーコンセプト">キーコンセプト</a></p>
<p class="h3"><a href="#コンテキストプロトコル">コンテキストプロトコル</a></p>
<p class="h3"><a href="#コンテキストオブジェクト">コンテキストオブジェクト</a></p>
<p class="h3"><a href="#プロバイダ">プロバイダ</a></p>
<p class="h3"><a href="#コンシューマ">コンシューマ</a></p>
<p class="h3"><a href="#サブスクリプション">サブスクリプション</a></p>
<p class="h2"><a href="#使い方">使い方</a></p>
<p class="h3"><a href="#コンテキストを定義する">コンテキストを定義する</a></p>
<p class="h4"><a href="#コンテキストの型チェック">コンテキストの型チェック</a></p>
<p class="h4"><a href="#コンテキストの比較">コンテキストの比較</a></p>
<p class="h3"><a href="#値をセットする">値をセットする</a></p>
<p class="h4"><a href="#_provide()デコレータ">@provide()デコレータ</a></p>
<p class="h4"><a href="#ContextProvider">ContextProvider</a></p>
<p class="h3"><a href="#コンシューマ">コンシューマ</a></p>
<p class="h4"><a href="#_consume()デコレータ">@consume()デコレータ</a></p>
<p class="h4"><a href="#ContextConsumer">ContextConsumer</a></p>
<p class="h4"><a href="#サブスクライブ">サブスクライブ</a></p>
<p class="h2"><a href="#ユースケース">ユースケース</a></p>
<p class="h3"><a href="#ユーザデータ、ロケール等">ユーザデータ、ロケール等</a></p>
<p class="h3"><a href="#サービス">サービス</a></p>
<p class="h3"><a href="#テーマ">テーマ</a></p>
<p class="h3"><a href="#HTMLベースのプラグイン">HTMLベースのプラグイン</a></p>
<p class="h3"><a href="#データフォーマッタ、リンクジェネレータ等">データフォーマッタ、リンクジェネレータ等</a></p>
<p class="h2"><a href="#API">API</a></p>
<p class="h3"><a href="#createContext()">createContext()</a></p>
<p class="h3"><a href="#_provide()">@provide()</a></p>
<p class="h3"><a href="#_consume()">@consume()</a></p>
<p class="h3"><a href="#ContextProvider">ContextProvider</a></p>
<p class="h3"><a href="#ContextConsumer">ContextConsumer</a></p>
<p class="h3"><a href="#ContextRoot">ContextRoot</a></p>
<p class="h3"><a href="#ContextRequestEvent">ContextRequestEvent</a></p>
<p class="h3"><a href="#ContextCallback">ContextCallback</a></p>
<p class="h2"><a href="#License">License</a></p>
<p class="h3"><a href="#Japanese_part">Japanese part</a></p>
<p class="h3"><a href="#Other">Other</a></p></nav></div>
    <footer class="footer markdown-body">
      <a href="/lit">Top</a>
    </footer>
  </body>
</html>