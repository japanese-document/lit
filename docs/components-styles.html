<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="twitter:card" content="summary" />
    <meta property="og:url" content="https://japanese-document.github.io/lit/components-styles.html" />
    <meta property="og:title" content="スタイル" />
    <meta property="og:description" content="コンポーネントのテンプレートはshadow rootにレンダリングされます。コンポーネントに追加されたスタイルは自動的にshadow root内にスコープされます。つまり、そのスタイルはコンポーネントのshadow root内の要素にのみ影響を与えます。Shadow DOMによってスタイルのカプセル化がされます。LitがShadow DOMを使わなかった場合、コンポーネントの外側にある要素(親要素や子要素も含む)に誤ってスタイルを適用にしないように注意する必要があります。そのためにクラス名を長くて面倒な物にしないといけないかもしれません。Shadow DOMを使うことによって、コンポーネントに" />
    <meta property="og:image" content="https://avatars2.githubusercontent.com/u/42838312?s=400" />
    <meta name="theme-color" content="#f1f7fe" />
    <meta name="description" content="コンポーネントのテンプレートはshadow rootにレンダリングされます。コンポーネントに追加されたスタイルは自動的にshadow root内にスコープされます。つまり、そのスタイルはコンポーネントのshadow root内の要素にのみ影響を与えます。Shadow DOMによってスタイルのカプセル化がされます。LitがShadow DOMを使わなかった場合、コンポーネントの外側にある要素(親要素や子要素も含む)に誤ってスタイルを適用にしないように注意する必要があります。そのためにクラス名を長くて面倒な物にしないといけないかもしれません。Shadow DOMを使うことによって、コンポーネントに" />
    <title>スタイル</title>
    <link rel="stylesheet" href="/lit/app.css?v=001" type="text/css"  media="all" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L9VVC74WWF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-L9VVC74WWF');
    </script>
  </head>
  <body class="container">
    <div class="left-side">
    <div class="index-menu">
      <details open="">
        <summary>コンポーネント</summary>
        <p><a href="https://japanese-document.github.io/lit/components-defining.html">定義</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-rendering.html">レンダリング</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-properties.html">リアクティブプロパティ</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-styles.html">スタイル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-lifecycle.html">ライフサイクル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-shadow-dom.html">Shadow DOM</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-events.html">イベント</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-decorators.html">デコレータ</a></p>
      </details>
      <details open="">
        <summary>テンプレート</summary>
        <p><a href="https://japanese-document.github.io/lit/templates-expressions.html">Expressions</a></p>
      </details>
      <details open="">
        <summary>API</summary>
        <p><a href="https://japanese-document.github.io/lit/api-LitElement.html">LitElement</a></p>
        <p><a href="https://japanese-document.github.io/lit/api-templates.html">テンプレート</a></p>
      </details>
    </div></div>
    <main class="main markdown-body">
      <h1 id="スタイル"><a href="#スタイル">スタイル</a></h1>
<p>コンポーネントのテンプレートは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot">shadow root</a>にレンダリングされます。
コンポーネントに追加されたスタイルは自動的にshadow root内にスコープされます。
つまり、そのスタイルはコンポーネントのshadow root内の要素にのみ影響を与えます。</p>
<p><a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">Shadow DOM</a>によってスタイルのカプセル化がされます。
LitがShadow DOMを使わなかった場合、コンポーネントの外側にある要素(親要素や子要素も含む)に誤ってスタイルを適用にしないように注意する必要があります。
そのためにクラス名を長くて面倒な物にしないといけないかもしれません。
Shadow DOMを使うことによって、
コンポーネントに記述したセレクタは、コンポーネントのshadow root内の要素にのみ適用されます。</p>
<h2 id="コンポーネントにスタイルを加える"><a href="#コンポーネントにスタイルを加える">コンポーネントにスタイルを加える</a></h2>
<p><code>static styles</code>クラスフィールドに<code>css</code>タグ関数を付けでCSSを記述することで適用範囲が限定されているスタイルを定義します。
この方法でスタイルを定義することでパフォーマンスが最適化されます。</p>
<pre><code class="language-ts">import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    p {
      color: green;
    }
  `;
  protected render() {
    return html`&lt;p&gt;I am green!&lt;/p&gt;`;
  }
}
</code></pre>
<p>コンポーネントに追加されたスタイルはShadow DOMによって適用範囲が限定されます。
概要は<a class="Link" href="#Shadow_DOM">Shadow DOM</a>を見てください。</p>
<p><code>static styles</code>クラスフィールドを下記のように記述します。</p>
<ul>
<li><p>タグが付いたテンプレート1つ</p>
<pre><code class="language-js">static styles = css`...`;
</code></pre>
</li>
<li><p>タグが付いたテンプレートの配列</p>
<pre><code class="language-js">static styles = [ css`...`, css`...`];
</code></pre>
</li>
</ul>
<p>ほとんどの場合、<code>static styles</code>クラスフィールドを使う方法はコンポーネントのスタイルを定義するベストプラクティスです。
インスタンス毎にスタイルを変更するようなユースケースでは、この方法では達成することができません。
スタイルを追加する別の方法は<a class="Link" href="#テンプレート内で適用範囲が限定されているスタイルを定義する">テンプレート内で適用範囲が限定されているスタイルを定義する</a>を見てください。</p>
<h3 id="static_styles内でエクスプレッションを使う"><a href="#static_styles内でエクスプレッションを使う">static styles内でエクスプレッションを使う</a></h3>
<p><code>static styles</code>はコンポーネントクラスのすべてのインスタンスに適用されます。
cssタグ内のエクスプレッションは一度だけ評価されます。そして、それらはすべてのインスタンスに使われます。</p>
<p>DOMツリー毎もしくはインスタンス毎のスタイルの変更は<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties">CSSカスタムプロパティ</a>を使って要素に<a class="Link" href="#テーマ">テーマ</a>を適用できるようにします。</p>
<p>Litコンポーネントが悪意のあるコードを実行する可能性を排除するために、
<code>css</code>タグは下記のようにエクスプレッションにcssタグが付与された文字列または数値のみを受け付けます。</p>
<pre><code class="language-js">const mainColor = css`red`;
const fontSize = 20;
...
static styles = css`
  div { color: ${mainColor}; font-size: ${fontSize}px; }
`;
</code></pre>
<p>この制限はURLパラメータやデータベースの値のような信頼できない所から取得した悪意のあるスタイルやコードを埋め込むことによるセキュリティ面の脆弱性からアプリケーションを保護するための物です。</p>
<p>あなた自身で定義した定数のように信頼できる値の場合、下記のように値を<code>unsafeCSS</code>関数に渡してエクスプレッションにセットすることができます。</p>
<pre><code class="language-js">const mainColor = 'red';
...
static styles = css`
  div { color: ${unsafeCSS(mainColor)} }
`;
</code></pre>
<p>サニタイズされていないCSSを挿入することはセキュリティリスクになるので、
<code>unsafeCSS</code>関数には信頼できる入力のみ渡します。</p>
<h3 id="スーパークラスのスタイルを継承する"><a href="#スーパークラスのスタイルを継承する">スーパークラスのスタイルを継承する</a></h3>
<p>下記のようにコンポーネントはタグ付けされたテンプレートリテラルの配列を使うことで、スーパークラスのスタイルを継承して、それ自身のスタイルを追加することができます。</p>
<pre><code class="language-ts">import {LitElement, html, css, CSSResultGroup} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('super-element')
export class SuperElement extends LitElement {
  static styles = css`
    div {
      border: 1px solid gray;
      padding: 8px;
    }
  ` as CSSResultGroup;
  protected render() {
    return html`
      &lt;div&gt;Content&lt;/div&gt;
    `;
  }
}

@customElement('my-element')
export class MyElement extends SuperElement {
  static styles = [
    SuperElement.styles,
    css`div {
      color: red;
    }`
  ];
}
</code></pre>
<p>JavaScriptでは<code>super.styles</code>でスーパークラスの<code>styles</code>プロパティを参照することができます。
TypeScriptを使う場合、
コンパイラが常に正しく<code>super.styles</code>を変換するとは限らないので<code>super.styles</code>を使わないことを推奨します。
この問題を避けるために上記の例のように明示的にスーパークラスの<code>styles</code>プロパティを参照します。</p>
<p>TypeScriptでサブクラスに継承されることを意図したコンポーネントを記述する場合は、
<code>static styles</code>フィールドに<code>CSSResultGroup</code>型を指定します。これによって、<code>styles</code>を配列でオーバーライドできるようになり柔軟になります。</p>
<pre><code class="language-ts">// TypeScriptが`styles`の型を`CSSResult`に限定することを防ぎます。
// これでサブクラスが`[SuperElement.styles, css`...`]`のような値をセットすることができます。
static styles: CSSResultGroup = css`...`;
</code></pre>
<h3 id="スタイルを共有する"><a href="#スタイルを共有する">スタイルを共有する</a></h3>
<p>タグ付けされたスタイルをexportしたモジュールを作成することによってコンポーネント間でスタイルを共有することができます。</p>
<pre><code class="language-js">export const buttonStyles = css`
  .blue-button {
    color: white;
    background-color: blue;
  }
  .blue-button:disabled {
    background-color: grey;
  }`;
</code></pre>
<p>下記のようにスタイルをimportして<code>static styles</code>クラスフィールドにスタイルを追加することができます。</p>
<pre><code class="language-js">import { buttonStyles } from './button-styles.js';

class MyElement extends LitElement {
  static styles = [
    buttonStyles,
    css`
      :host { display: block;
        border: 1px solid black;
      }`
  ];
}
</code></pre>
<h3 id="スタイルでUnicodeエスケープを使う"><a href="#スタイルでUnicodeエスケープを使う">スタイルでUnicodeエスケープを使う</a></h3>
<p>CSSのUnicodeエスケープシーケンスはバックスラッシュの後に4桁もしくは6桁の16進数の数字の文字列です。
例えば、"•"は<code>\2022</code>です。
これはJavaScriptで非推奨の8進数のエスケープシーケンスのフォーマットに該当します。
これらのシーケンスを<code>css</code>がタグ付けされたテンプレートリテラルで使うとエラーが発生します。</p>
<p>スタイルにUnicodeエスケープを加える方法は下記の2つです。</p>
<ul>
<li>2つ目のバックスラッシュを加えます (例: <code>\\2022</code>)。</li>
<li>先頭に<code>\u</code>を付けてJavaScriptのエスケープシーケンスを使います (例: <code>\u2022</code>)。</li>
</ul>
<pre><code class="language-js">static styles = css`
  div::before {
    content: '\u2022';
  }
</code></pre>
<h3 id="CSS_module_scriptsを使う"><a href="#CSS_module_scriptsを使う">CSS module scriptsを使う</a></h3>
<p>CSS module scriptsを使うと<code>.css</code>ファイルをCSSStyleSheetインスタンスでimportすることができます。
下記のように<code>static styles</code>クラスフィールドにCSSStyleSheetインスタンスをセットすることができます。</p>
<p>index.html:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script type="module" src="./my-element.js"&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;my-element&gt;&lt;/my-element&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>style.css:</p>
<pre><code class="language-css">:host { color: green; }
div {
  border: solid red 1px;
  padding: 30px;
}
</code></pre>
<p>my-element.js:</p>
<pre><code class="language-js">import { html, LitElement } from 'lit'
import sheet from './style.css' assert { type: 'css' }

class MyElement extends LitElement {
  static styles = sheet
  render() {
    return html`&lt;div&gt;test&lt;/div&gt;`
  }
}

customElements.define('my-element', MyElement)
</code></pre>
<h2 id="Shadow_DOM"><a href="#Shadow_DOM">Shadow DOM</a></h2>
<p>このセクションではShadow DOMにスタイルを設定する方法を説明します。</p>
<p>コンポーネントに追加したスタイルは以下のコンポーネントの3つの部分に影響を与えます。</p>
<ul>
<li><a class="Link" href="#Shadow_treeのスタイルを設定する">Shadow tree</a> (コンポーネントがテンプレートをレンダリングした物)</li>
<li><a class="Link" href="#コンポーネント自身のスタイルを設定する">コンポーネント自身</a></li>
<li><a class="Link" href="#子要素のスタイルを設定する">子要素</a></li>
</ul>
<h3 id="Shadow_treeのスタイルを設定する"><a href="#Shadow_treeのスタイルを設定する">Shadow treeのスタイルを設定する</a></h3>
<p>デフォルトでLitはテンプレートをShadow tree内にレンダリングします。
要素の<a class="Link" href="https://developer.mozilla.org/en-US/docs/Glossary/Shadow_tree">shadow tree</a>に適用範囲を限定したスタイルはメインdocumentおよび他のshadow treeに影響を与えません。
同様に<a class="Link" href="#CSSを継承する">継承されるCSSプロパティ</a>を除いて、document内のスタイルはshadow tree内のコンテンツに影響を与えません。</p>
<p><code>static styles</code>で標準のCSSセレクタを使うと、コンポーネントのshadow tree内の要素のみマッチします。
これによって、意図せずページ内の要素にスタイルが適用されることを憂慮しなくてもよくなるので、シンプルなセレクタ(例: <code>input</code>、<code>*</code>、<code>#my-element</code>)を多用することができます。</p>
<h3 id="コンポーネント自身のスタイルを設定する"><a href="#コンポーネント自身のスタイルを設定する">コンポーネント自身のスタイルを設定する</a></h3>
<p>特別なセレクタである<code>:host</code>を使うと、コンポーネント自身のスタイルを設定することができます。
(shadow treeを所有する要素をhost elementと呼びます。)</p>
<p><a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:host">:host</a> CSS pseudo-classもしくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:host_function">:host()</a> CSS pseudo-class関数を使うと、host elementのデフォルトのスタイルをセットすることができます。</p>
<ul>
<li><code>:host</code>はhost elementに対応します。</li>
<li><code>:host(selector)</code>は<code>selector</code>セレクタにマッチするhost elementのみに対応します。</li>
</ul>
<pre><code class="language-ts">import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators/custom-element.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    :host {
      display: block;
      background-color: lightgray;
      padding: 8px;
    }
    :host(.blue) {
      background-color: aliceblue;
      color: darkgreen;
    }
  `;
  protected render() {
    return html`Hello World`;
  }
}
</code></pre>
<p>host element自身のスタイルはshadow treeの外部から影響を受けることがあります。
例えば、下記のようなスタイルは<code>:host</code>および<code>:host()</code>で設定されたスタイルを上書きします。
つまり、<code>:host</code>および<code>:host()</code>で設定されたスタイルはデフォルトのスタイルと見なすことができます。</p>
<pre><code class="language-css">my-element {
  display: inline-block;
}
</code></pre>
<h3 id="子要素のスタイルを設定する"><a href="#子要素のスタイルを設定する">子要素のスタイルを設定する</a></h3>
<p>コンポーネントに(<code>&lt;ul&gt;</code>要素に<code>&lt;li&gt;</code>要素を配置するように)子コンポーネントを配置することができます。
子コンポーネントをレンダリングするには、テンプレートに1つまたは複数の<code>&lt;slot&gt;</code>を配置する必要があります。
詳しくは<a class="Link" href="https://lit.dev/docs/components/shadow-dom/#slots">slot要素を使って子コンポーネントをレンダリングする</a>を見てください。</p>
<p><code>&lt;slot&gt;</code>を使ってshadow tree内でhost elementの子要素が配置される位置を指定します。</p>
<p><a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/::slotted">::slotted()</a> CSS pseudo-elementを使って<code>&lt;slot&gt;</code>と置き換わる要素を指定することができます。</p>
<ul>
<li><code>::slotted(*)</code> すべての置き換わる要素にマッチします。</li>
<li><code>::slotted(p)</code> 置き換わる要素が<code>&lt;p&gt;</code>の場合、マッチします。</li>
<li><code>p ::slotted(*)</code> 置き換わる要素が<code>&lt;p&gt;</code>の子要素の場合、マッチします。</li>
</ul>
<pre><code class="language-ts">import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    ::slotted(*) { font-family: Roboto; }
    ::slotted(p) { color: blue; }
    div ::slotted(*) { color: red; }
  `;
  protected render() {
    return html`
      &lt;slot&gt;&lt;/slot&gt;
      &lt;div&gt;&lt;slot name="hi"&gt;&lt;/slot&gt;&lt;/div&gt;
    `;
  }
}
</code></pre>
<p><code>::slotted()</code>でスタイルを設定することができる要素は<code>&lt;slot&gt;</code>と置き換わる要素のみであることに注意してください。</p>
<pre><code class="language-html">&lt;my-element&gt;
  &lt;div&gt;Stylable with ::slotted()&lt;/div&gt;
&lt;/my-element&gt;

&lt;my-element&gt;
  &lt;div&gt;&lt;p&gt;Not stylable with ::slotted()&lt;/p&gt;&lt;/div&gt;
&lt;/my-element&gt;
</code></pre>
<p><code>::slotted()</code>で設定したスタイルは下記のように上書きすることができます。
つまり<code>::slotted()</code>で設定したスタイルはデフォルトのスタイルと見なすことができます。</p>
<pre><code class="language-css">my-element &gt; div {
  /* 置き換えられる子要素を外部のスタイルから対象にすることで::slotted()を使ってセットしたスタイルを上書きすることができます。 */
}
</code></pre>
<h2 id="テンプレート内で適用範囲が限定されているスタイルを定義する"><a href="#テンプレート内で適用範囲が限定されているスタイルを定義する">テンプレート内で適用範囲が限定されているスタイルを定義する</a></h2>
<p>パフォーマンスを最適化するために<a class="Link" href="#コンポーネントにスタイルを加える"><code>static styles</code>クラスフィールド</a>を使うことを推奨します。
しかし、Litテンプレートでスタイルを定義したい時もあるでしょう。
テンプレートで適用範囲が限定されたスタイルを加える方法は下記の2つです。</p>
<ul>
<li><a class="Link" href="#style要素を使ってスタイルを定義する"><code>&lt;style&gt;</code>要素</a>を使ってスタイルを追加する。</li>
<li><a class="Link" href="#外部のスタイルシートをインポートする(非推奨)">外部のスタイルシート</a>を使ってスタイルを追加する。(非推奨)</li>
</ul>
<p>これらの方法はそれぞれ利点と欠点があります。</p>
<h3 id="style要素を使ってスタイルを定義する"><a href="#style要素を使ってスタイルを定義する">style要素を使ってスタイルを定義する</a></h3>
<p>通常、スタイルは<a class="Link" href="#コンポーネントにスタイルを加える"><code>static styles</code>クラスフィールド</a>に配置されます。
<code>static styles</code>クラスフィールドはクラス毎に1度のみ評価されます。
インスタンス毎にスタイルを設定する必要がある時もあるかもしれません。
このために、CSS propertiesを使って<a class="Link" href="#テーマ">テーマ可能な要素</a>を作成することを推奨します。
それか、<code>&lt;style&gt;</code>要素をLitテンプレート内に配置します。
これらはインスタンス毎に更新されます。</p>
<pre><code class="language-js">render() {
  return html`
    &lt;style&gt;
      /* インスタンス毎に更新されます。 */
    &lt;/style&gt;
    &lt;div&gt;template content&lt;/div&gt;
  `;
}
</code></pre>
<h4 id="エクスプレッションとstyle要素"><a href="#エクスプレッションとstyle要素">エクスプレッションとstyle要素</a></h4>
<p>style要素内でエクスプレッションを使うことは重大なパフォーマンスの問題があります。</p>
<pre><code class="language-js">render() {
  return html`
    &lt;style&gt;
      :host {
        /* このアプローチは重大なパフォーマンスの問題があります。 */
        color: ${myColor}
      }
    &lt;/style&gt;
    &lt;div&gt;template content&lt;/div&gt;
  `;
}
</code></pre>
<p><code>&lt;style&gt;</code>要素内でエクスプレッションを評価することはとても非効率です。
<code>&lt;style&gt;</code>要素内のテキストが変更されると、ブラウザは<code>&lt;style&gt;</code>要素全体を再パース処理をします。</p>
<p>このコストを軽減するには、下記のようにインスタンス毎に評価する必要があるスタイルとそうでないスタイルに分割します。</p>
<pre><code class="language-js">  static styles = css`/* ... */`;
  render() {
    const redStyle = html`&lt;style&gt; :host { color: red; } &lt;/style&gt;`;
    return html`${this.red ? redStyle : ''}`
</code></pre>
<h3 id="外部のスタイルシートをインポートする(非推奨)"><a href="#外部のスタイルシートをインポートする(非推奨)">外部のスタイルシートをインポートする(非推奨)</a></h3>
<p><code>&lt;link&gt;</code>をテンプレート内に配置して外部のスタイルシートを使うことができますが、この方法は非推奨です。
代わりに<a class="Link" href="#コンポーネントにスタイルを加える"><code>static styles</code>クラスフィールド</a>を使うべきです。</p>
<h4 id="外部のスタイルシートを使う際の注意事項"><a href="#外部のスタイルシートを使う際の注意事項">外部のスタイルシートを使う際の注意事項</a></h4>
<ul>
<li><a class="Link" href="https://github.com/webcomponents/polyfills/tree/master/packages/shadycss#limitations">ShadyCSS polyfill</a>は外部のスタイルシートをサポートしません。</li>
<li>外部のスタイルシートはロード時にcause a flash-of-unstyled-content (FOUC)を引き起こす可能性があります。</li>
<li><code>href</code>属性のURLはメインdocumentに相対的です。これは使用されるURL構造を固定しているときは問題ありません。不特定のURL構造で使用されることを想定している場合、外部のスタイルシートを使うことは避けるべきです。</li>
</ul>
<h2 id="動的なclass属性とstyle属性"><a href="#動的なclass属性とstyle属性">動的なclass属性とstyle属性</a></h2>
<p>スタイルを動的にする1つの方法はHTMLテンプレート内の<code>class</code>属性もしくは<code>style</code>属性の値をエクスプレッションを使ってセットすることです。</p>
<p>容易にHTMLテンプレート内の<code>class</code>属性もしくは<code>style</code>属性にエクスプレッションを使って値を適用できるように、Litは<code>classMap</code>と<code>styleMap</code>という２つのディレクティブを提供します。</p>
<p>詳しくは<a class="Link" href="https://lit.dev/docs/templates/directives/">ビルドインディレクティブ</a>を見てください。</p>
<p>以下は<a class="Link" href="https://lit.dev/docs/templates/directives/#classmap">classMap</a>と<a class="Link" href="https://lit.dev/docs/templates/directives/#stylemap">styleMap</a>の簡単な使い方の例です。</p>
<ol>
<li>importします。</li>
</ol>
<pre><code class="language-ts">import { classMap } from 'lit/directives/class-map.js';
import { styleMap } from 'lit/directives/style-map.js';
</code></pre>
<ol start="2">
<li>テンプレート内に配置します。</li>
</ol>
<pre><code class="language-ts">import {LitElement, html, css} from 'lit';
import {customElement, property} from 'lit/decorators.js';
import {classMap} from 'lit/directives/class-map.js';
import {styleMap} from 'lit/directives/style-map.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    .someclass { border: 1px solid red; padding: 4px; }
    .anotherclass { background-color: navy; }
  `;
  @property()
  classes = { someclass: true, anotherclass: true };
  @property()
  styles = { color: 'lightgreen', fontFamily: 'Roboto' };
  protected render() {
    return html`
      &lt;div class=${classMap(this.classes)} style=${styleMap(this.styles)}&gt;
        Some content
      &lt;/div&gt;
    `;
  }
}
</code></pre>
<p>詳しくは<a class="Link" href="https://lit.dev/docs/templates/directives/#classmap">classMap</a>と<a class="Link" href="https://lit.dev/docs/templates/directives/#stylemap">styleMap</a>を見てください。</p>
<h2 id="テーマ"><a href="#テーマ">テーマ</a></h2>
<p><a class="Link" href="#CSSを継承する">CSSを継承</a>と<a class="Link" href="#CSSカスタムプロパティ">CSS変数とカスタムプロパティ</a>を併用すると
簡単にテーマ設定可能な要素を作成することができます。
CSSカスタムプロパティの変更をCSSセレクタに適用することによって、
ツリーベースおよびインスタンス毎のテーマを簡単に適用することができます。
以下はその例です。</p>
<pre><code class="language-ts">import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    :host {
      color: var(--my-element-text-color, black);
      background: var(--my-element-background-color, white);
      font-family: var(--my-element-font-family, Roboto);
      display: block;
      padding: 8px;
      margin: 8px;
    }
  `;
  protected render() {
    return html`&lt;div&gt;Hello World&lt;/div&gt;`;
  }
}
</code></pre>
<h3 id="CSSを継承する"><a href="#CSSを継承する">CSSを継承する</a></h3>
<p>CSSの継承によって親要素およびhost elementsはそれらで設定されている特定のCSSプロパティをそれらの子孫の要素に適用することができます。</p>
<p>すべてのCSSプロパティが継承されるわけではありません。下記のCSSプロパティのみが継承されます。</p>
<ul>
<li><code>color</code></li>
<li><code>font-family</code>とそれ以外の<code>font-*</code>プロパティ</li>
<li>すべてのCSSカスタムプロパティ(<code>--*</code>)</li>
</ul>
<p>詳しくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/inheritance">CSSの継承</a>を見てください。</p>
<p>下記のようにCSSの継承を使って親要素にスタイルを設定することでそれを子孫の要素に適用することができます。</p>
<pre><code class="language-html">&lt;style&gt;
html {
  color: green;
}
&lt;/style&gt;
&lt;my-element&gt;
  #shadow-root
    Will be green
&lt;/my-element&gt;
</code></pre>
<h3 id="CSSカスタムプロパティ"><a href="#CSSカスタムプロパティ">CSSカスタムプロパティ</a></h3>
<p>すべてのCSSカスタムプロパティ(<code>--custom-property-name</code>)は継承されます。
これを使って外部からコンポーネントのスタイルを変更することができます。</p>
<p>下記のコンポーネントはCSS変数を<code>background-color</code>にセットしています。
CSS変数はコンポーネントの先祖の要素で<code>--my-background</code>が設定されている場合はその値を使います。そうでない場合は<code>yellow</code>を使います。</p>
<pre><code class="language-js">class MyElement extends LitElement {
  static styles = css`
    :host {
      background-color: var(--my-background, yellow);
    }
  `;
  render() {
    return html`&lt;p&gt;Hello world&lt;/p&gt;`;
  }
}
</code></pre>
<p>下記のように<code>my-element</code>タグをCSSセレクタとして使ってコンポーネントに<code>--my-background</code>の値を適用することもできます。</p>
<pre><code class="language-html">&lt;style&gt;
  my-element {
    --my-background: rgb(67, 156, 144);
  }
&lt;/style&gt;
&lt;my-element&gt;&lt;/my-element&gt;
</code></pre>
<p>下記のように<code>--my-background</code>を<code>my-element</code>のインスタンス毎に設定することができます。</p>
<pre><code class="language-html">&lt;style&gt;
  my-element {
    --my-background: rgb(67, 156, 144);
  }
  my-element.stuff {
    --my-background: #111111;
  }
&lt;/style&gt;
&lt;my-element&gt;&lt;/my-element&gt;
&lt;my-element class="stuff"&gt;&lt;/my-element&gt;
</code></pre>
<p>詳しくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/--*">CSSカスタムプロパティ</a>を見てください。</p>
<hr>
<h2 id="License"><a href="#License">License</a></h2>
<h3 id="Japanese_part"><a href="#Japanese_part">Japanese part</a></h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by-nc/4.0/legalcode">Creative Commons Attribution-NonCommercial 4.0 International Public License</a></p>
<p>Copyright (c) 2022 38elements</p>
<h3 id="Other"><a href="#Other">Other</a></h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by/3.0/deed.en">Creative Commons Attribution 3.0 Unported</a></p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>BSD 3-Clause License</p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ol>
<li><p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p>
</li>
<li><p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p>
</li>
<li><p>Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.</p>
</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </main>
    <div class="right-side"><div class="header-list"><p class="h1"><a href="#スタイル">スタイル</a></p>
<p class="h2"><a href="#コンポーネントにスタイルを加える">コンポーネントにスタイルを加える</a></p>
<p class="h3"><a href="#static_styles内でエクスプレッションを使う">static styles内でエクスプレッションを使う</a></p>
<p class="h3"><a href="#スーパークラスのスタイルを継承する">スーパークラスのスタイルを継承する</a></p>
<p class="h3"><a href="#スタイルを共有する">スタイルを共有する</a></p>
<p class="h3"><a href="#スタイルでUnicodeエスケープを使う">スタイルでUnicodeエスケープを使う</a></p>
<p class="h3"><a href="#CSS_module_scriptsを使う">CSS module scriptsを使う</a></p>
<p class="h2"><a href="#Shadow_DOM">Shadow DOM</a></p>
<p class="h3"><a href="#Shadow_treeのスタイルを設定する">Shadow treeのスタイルを設定する</a></p>
<p class="h3"><a href="#コンポーネント自身のスタイルを設定する">コンポーネント自身のスタイルを設定する</a></p>
<p class="h3"><a href="#子要素のスタイルを設定する">子要素のスタイルを設定する</a></p>
<p class="h2"><a href="#テンプレート内で適用範囲が限定されているスタイルを定義する">テンプレート内で適用範囲が限定されているスタイルを定義する</a></p>
<p class="h3"><a href="#style要素を使ってスタイルを定義する">style要素を使ってスタイルを定義する</a></p>
<p class="h4"><a href="#エクスプレッションとstyle要素">エクスプレッションとstyle要素</a></p>
<p class="h3"><a href="#外部のスタイルシートをインポートする(非推奨)">外部のスタイルシートをインポートする(非推奨)</a></p>
<p class="h4"><a href="#外部のスタイルシートを使う際の注意事項">外部のスタイルシートを使う際の注意事項</a></p>
<p class="h2"><a href="#動的なclass属性とstyle属性">動的なclass属性とstyle属性</a></p>
<p class="h2"><a href="#テーマ">テーマ</a></p>
<p class="h3"><a href="#CSSを継承する">CSSを継承する</a></p>
<p class="h3"><a href="#CSSカスタムプロパティ">CSSカスタムプロパティ</a></p>
<p class="h2"><a href="#License">License</a></p>
<p class="h3"><a href="#Japanese_part">Japanese part</a></p>
<p class="h3"><a href="#Other">Other</a></p></div></div>
    <footer class="footer markdown-body">
      <a href="/lit">Top</a>
    </footer>
  </body>
</html>