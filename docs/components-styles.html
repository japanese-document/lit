<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="twitter:card" content="summary" />
    <meta property="og:url" content="https://japanese-document.github.io/lit/components-styles.html" />
    <meta property="og:title" content="スタイル - Lit" />
    <meta property="og:description" content="コンポーネントのテンプレートはshadow rootにレンダリングされます。コンポーネントに追加されたスタイルは自動的にshadow root内にスコープされます。つまり、そのスタイルはコンポーネントのshadow root内の要素にのみ影響を与えます。Shadow DOMによってスタイルのカプセル化がされます。LitがShadow DOMを使わなかった場合、コンポーネントの外側にある要素(親要素や子要素も含む)に誤ってスタイルを適用にしないように注意する必要があります。そのためにクラス名を長くて面倒な物にしないといけないかもしれません。Shadow DOMを使うことによって、Litはコンポー" />
    <meta property="og:image" content="https://avatars2.githubusercontent.com/u/42838312?s=400" />
    <meta name="theme-color" content="#f1f7fe" />
    <meta name="description" content="コンポーネントのテンプレートはshadow rootにレンダリングされます。コンポーネントに追加されたスタイルは自動的にshadow root内にスコープされます。つまり、そのスタイルはコンポーネントのshadow root内の要素にのみ影響を与えます。Shadow DOMによってスタイルのカプセル化がされます。LitがShadow DOMを使わなかった場合、コンポーネントの外側にある要素(親要素や子要素も含む)に誤ってスタイルを適用にしないように注意する必要があります。そのためにクラス名を長くて面倒な物にしないといけないかもしれません。Shadow DOMを使うことによって、Litはコンポー" />
    <title>スタイル - Lit</title>
    <link rel="stylesheet" href="/lit/app.css?v=001" type="text/css"  media="all" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L9VVC74WWF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-L9VVC74WWF');
    </script>
  </head>
  <body class="container">
    <div class="side"></div>
    <main class="main markdown-body">
      <h1 id="スタイル"><a href="#スタイル">スタイル</a></h1>
<p>コンポーネントのテンプレートは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot">shadow root</a>にレンダリングされます。
コンポーネントに追加されたスタイルは自動的にshadow root内にスコープされます。
つまり、そのスタイルはコンポーネントのshadow root内の要素にのみ影響を与えます。</p>
<p><a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">Shadow DOM</a>によってスタイルのカプセル化がされます。
LitがShadow DOMを使わなかった場合、コンポーネントの外側にある要素(親要素や子要素も含む)に誤ってスタイルを適用にしないように注意する必要があります。
そのためにクラス名を長くて面倒な物にしないといけないかもしれません。
Shadow DOMを使うことによって、
Litはコンポーネントにセレクタ記述したセレクタをすべてコンポーネントのshadow root内の要素にのみ適用します。</p>
<h2 id="コンポーネントにスタイルを加える"><a href="#コンポーネントにスタイルを加える">コンポーネントにスタイルを加える</a></h2>
<p><code>static styles</code>クラスフィールドに<code>css</code>タグ関数を付けでCSSを記述することで適用範囲が限定されているスタイルを定義します。
この方法でスタイルを定義することでパフォーマンスが最適化されます。</p>
<pre><code class="language-ts">import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    p {
      color: green;
    }
  `;
  protected render() {
    return html`&lt;p&gt;I am green!&lt;/p&gt;`;
  }
}
</code></pre>
<p>コンポーネントに追加されたスタイルはShadow DOMによって適用範囲が限定されます。
概要は<a class="Link" href="#Shadow_DOM">Shadow DOM</a>を見てください。</p>
<p><code>static styles</code>クラスフィールドを下記のように記述します。</p>
<ul>
<li><p>タグが付いたテンプレート1つ</p>
<pre><code class="language-js">static styles = css`...`;
</code></pre>
</li>
<li><p>タグが付いたテンプレートの配列</p>
<pre><code class="language-js">static styles = [ css`...`, css`...`];
</code></pre>
</li>
</ul>
<p>ほとんどの場合、<code>static styles</code>クラスフィールドを使う方法はコンポーネントのスタイルを定義するベストプラクティスです。
インスタンス毎にスタイルを変更するようなユースケースでは、この方法では達成することができません。
スタイルを追加する別の方法は<a class="Link" href="#テンプレート内で適用範囲が限定されているスタイルを定義する">テンプレート内で適用範囲が限定されているスタイルを定義する</a>を見てください。</p>
<h3 id="static_styles内でエクスプレッションを使う"><a href="#static_styles内でエクスプレッションを使う">static styles内でエクスプレッションを使う</a></h3>
<p><code>static styles</code>はコンポーネントクラスのすべてのインスタンスに適用されます。
cssタグ内のエクスプレッションは一度だけ評価されます。そして、それらはすべてのインスタンスに使われます。</p>
<p>DOMツリー毎もしくはインスタンス毎のスタイルの変更は<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties">CSSカスタムプロパティ</a>を使って要素に<a class="Link" href="#テーマ">テーマ</a>を適用できるようにします。</p>
<p>Litコンポーネントが悪意のあるコードを実行する可能性を排除するために、
<code>css</code>タグは下記のようにエクスプレッションにcssタグが付与された文字列または数値のみを受け付けます。</p>
<pre><code class="language-js">const mainColor = css`red`;
const fontSize = 20;
...
static styles = css`
  div { color: ${mainColor}; font-size: ${fontSize}px; }
`;
</code></pre>
<p>この制限はURLパラメータやデータベースの値のような信頼できない所から取得した悪意のあるスタイルやコードを埋め込むことによるセキュリティ面の脆弱性からアプリケーションを保護するための物です。</p>
<p>あなた自身で定義した定数のように信頼できる値の場合、下記のように値を<code>unsafeCSS</code>関数に渡してエクスプレッションにセットすることができます。</p>
<pre><code class="language-js">const mainColor = 'red';
...
static styles = css`
  div { color: ${unsafeCSS(mainColor)} }
`;
</code></pre>
<p>サニタイズされていないCSSを挿入することはセキュリティリスクになるので、
<code>unsafeCSS</code>関数には信頼できる入力のみ渡します。</p>
<h3 id="スーパークラスのスタイルを継承する"><a href="#スーパークラスのスタイルを継承する">スーパークラスのスタイルを継承する</a></h3>
<p>下記のようにコンポーネントはタグ付けされたテンプレートリテラルの配列を使うことで、スーパークラスのスタイルを継承して、それ自身のスタイルを追加することができます。</p>
<pre><code class="language-ts">import {LitElement, html, css, CSSResultGroup} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('super-element')
export class SuperElement extends LitElement {
  static styles = css`
    div {
      border: 1px solid gray;
      padding: 8px;
    }
  ` as CSSResultGroup;
  protected render() {
    return html`
      &lt;div&gt;Content&lt;/div&gt;
    `;
  }
}

@customElement('my-element')
export class MyElement extends SuperElement {
  static styles = [
    SuperElement.styles,
    css`div {
      color: red;
    }`
  ];
}
</code></pre>
<p>JavaScriptでは<code>super.styles</code>でスーパークラスの<code>styles</code>プロパティを参照することができます。
TypeScriptを使う場合、
コンパイラが常に正しく<code>super.styles</code>を変換するとは限らないので<code>super.styles</code>を使わないことを推奨します。
この問題を避けるために上記の例のように明示的にスーパークラスの<code>styles</code>プロパティを参照します。</p>
<p>TypeScriptでサブクラスに継承されることを意図したコンポーネントを記述する場合は、
<code>static styles</code>フィールドに<code>CSSResultGroup</code>型を指定します。これによって、<code>styles</code>を配列でオーバーライドできるようになり柔軟になります。</p>
<pre><code class="language-ts">// TypeScriptが`styles`の型を`CSSResult`に限定することを防ぎます。
// これでサブクラスが`[SuperElement.styles, css`...`]`のような値をセットすることができます。
static styles: CSSResultGroup = css`...`;
</code></pre>
<h3 id="スタイルを共有する"><a href="#スタイルを共有する">スタイルを共有する</a></h3>
<p>タグ付けされたスタイルをexportしたモジュールを作成することによってコンポーネント間でスタイルを共有することができます。</p>
<pre><code class="language-js">export const buttonStyles = css`
  .blue-button {
    color: white;
    background-color: blue;
  }
  .blue-button:disabled {
    background-color: grey;
  }`;
</code></pre>
<p>下記のようにスタイルをimportして<code>static styles</code>クラスフィールドにスタイルを追加することができます。</p>
<pre><code class="language-js">import { buttonStyles } from './button-styles.js';

class MyElement extends LitElement {
  static styles = [
    buttonStyles,
    css`
      :host { display: block;
        border: 1px solid black;
      }`
  ];
}
</code></pre>
<h3 id="スタイルでUnicodeエスケープを使う"><a href="#スタイルでUnicodeエスケープを使う">スタイルでUnicodeエスケープを使う</a></h3>
<p>CSSのUnicodeエスケープシーケンスはバックスラッシュの後に4桁もしくは6桁の16進数の数字の文字列です。
例えば、"•"は<code>\2022</code>です。
これはJavaScriptで非推奨の8進数のエスケープシーケンスのフォーマットに該当します。
これらのシーケンスを<code>css</code>がタグ付けされたテンプレートリテラルで使うとエラーが発生します。</p>
<p>スタイルにUnicodeエスケープを加える方法は下記の2つです。</p>
<ul>
<li>2つ目のバックスラッシュを加えます (例: <code>\\2022</code>)。</li>
<li>先頭に<code>\u</code>を付けてJavaScriptのエスケープシーケンスを使います (例: <code>\u2022</code>)。</li>
</ul>
<pre><code class="language-js">static styles = css`
  div::before {
    content: '\u2022';
  }
</code></pre>
<h2 id="Shadow_DOM"><a href="#Shadow_DOM">Shadow DOM</a></h2>
<p>このセクションではShadow DOMにスタイルを設定する方法を説明します。</p>
<p>コンポーネントに追加したスタイルは以下のコンポーネントの3つの部分に影響を与えます。</p>
<ul>
<li><a class="Link" href="#Shadow_treeのスタイルを設定する">Shadow tree</a> (コンポーネントがテンプレートをレンダリングした物)</li>
<li><a class="Link" href="#コンポーネント自身のスタイルを設定する">コンポーネント自身</a></li>
<li><a class="Link" href="#子要素のスタイルを設定する">子要素</a></li>
</ul>
<h3 id="Shadow_treeのスタイルを設定する"><a href="#Shadow_treeのスタイルを設定する">Shadow treeのスタイルを設定する</a></h3>
<p>デフォルトでLitはテンプレートをShadow tree内にレンダリングします。
要素の<a class="Link" href="https://developer.mozilla.org/en-US/docs/Glossary/Shadow_tree">shadow tree</a>に適用範囲を限定したスタイルはメインdocumentおよび他のshadow treeに影響を与えません。
同様に<a class="Link" href="#CSSを継承する">継承されるCSSプロパティ</a>を除いて、document内のスタイルはshadow tree内のコンテンツに影響を与えません。</p>
<p><code>static styles</code>で標準のCSSセレクタを使うと、コンポーネントのshadow tree内の要素のみマッチします。
これによって、意図せずページ内の要素にスタイルが適用されることを憂慮しなくてもよくなるので、シンプルなセレクタ(例: <code>input</code>、<code>*</code>、<code>#my-element</code>)を多用することができます。</p>
<h3 id="コンポーネント自身のスタイルを設定する"><a href="#コンポーネント自身のスタイルを設定する">コンポーネント自身のスタイルを設定する</a></h3>
<p>特別なセレクタである<code>:host</code>を使うと、コンポーネント自身のスタイルを設定することができます。
(shadow treeを所有する要素をhost elementと呼びます。)</p>
<p><a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:host">:host</a> CSS pseudo-classもしくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/:host_function">:host()</a> CSS pseudo-class関数を使うと、host elementのデフォルトのスタイルをセットすることができます。</p>
<ul>
<li><code>:host</code>はhost elementに対応します。</li>
<li><code>:host(selector)</code>は<code>selector</code>セレクタにマッチするhost elementのみに対応します。</li>
</ul>
<pre><code class="language-ts">import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators/custom-element.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    :host {
      display: block;
      background-color: lightgray;
      padding: 8px;
    }
    :host(.blue) {
      background-color: aliceblue;
      color: darkgreen;
    }
  `;
  protected render() {
    return html`Hello World`;
  }
}
</code></pre>
<p>host element自身のスタイルはshadow treeの外部から影響を受けることがあります。
例えば、下記のようなスタイルは<code>:host</code>および<code>:host()</code>で設定されたスタイルを上書きします。
つまり、<code>:host</code>および<code>:host()</code>で設定されたスタイルはデフォルトのスタイルと見なすことができます。</p>
<pre><code class="language-css">my-element {
  display: inline-block;
}
</code></pre>
<h3 id="子要素のスタイルを設定する"><a href="#子要素のスタイルを設定する">子要素のスタイルを設定する</a></h3>
<p>コンポーネントに(<code>&lt;ul&gt;</code>要素に<code>&lt;li&gt;</code>要素を配置するように)子コンポーネントを配置することができます。
子コンポーネントをレンダリングするには、テンプレートに1つまたは複数の<code>&lt;slot&gt;</code>を配置する必要があります。
詳しくは<a class="Link" href="https://lit.dev/docs/components/shadow-dom/#slots">slot要素を使って子コンポーネントをレンダリングする</a>を見てください。</p>
<p><code>&lt;slot&gt;</code>を使ってshadow tree内でhost elementの子要素が配置される位置を指定します。</p>
<p><a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/::slotted">::slotted()</a> CSS pseudo-elementを使って<code>&lt;slot&gt;</code>と置き換わる要素を指定することができます。</p>
<ul>
<li><code>::slotted(*)</code> すべての置き換わる要素にマッチします。</li>
<li><code>::slotted(p)</code> 置き換わる要素が<code>&lt;p&gt;</code>の場合、マッチします。</li>
<li><code>p ::slotted(*)</code> 置き換わる要素が<code>&lt;p&gt;</code>の子要素の場合、マッチします。</li>
</ul>
<pre><code class="language-ts">import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    ::slotted(*) { font-family: Roboto; }
    ::slotted(p) { color: blue; }
    div ::slotted(*) { color: red; }
  `;
  protected render() {
    return html`
      &lt;slot&gt;&lt;/slot&gt;
      &lt;div&gt;&lt;slot name="hi"&gt;&lt;/slot&gt;&lt;/div&gt;
    `;
  }
}
</code></pre>
<p><code>::slotted()</code>でスタイルを設定することができる要素は<code>&lt;slot&gt;</code>と置き換わる要素のみであることに注意してください。</p>
<pre><code class="language-html">&lt;my-element&gt;
  &lt;div&gt;Stylable with ::slotted()&lt;/div&gt;
&lt;/my-element&gt;

&lt;my-element&gt;
  &lt;div&gt;&lt;p&gt;Not stylable with ::slotted()&lt;/p&gt;&lt;/div&gt;
&lt;/my-element&gt;
</code></pre>
<p><code>::slotted()</code>で設定したスタイルは下記のように上書きすることができます。
つまり<code>::slotted()</code>で設定したスタイルはデフォルトのスタイルと見なすことができます。</p>
<pre><code class="language-css">my-element &gt; div {
  /* 置き換えられる子要素を外部のスタイルから対象にすることで::slotted()を使ってセットしたスタイルを上書きすることができます。 */
}
</code></pre>
<h2 id="テンプレート内で適用範囲が限定されているスタイルを定義する"><a href="#テンプレート内で適用範囲が限定されているスタイルを定義する">テンプレート内で適用範囲が限定されているスタイルを定義する</a></h2>
<p>パフォーマンスを最適化するために<a class="Link" href="#コンポーネントにスタイルを加える"><code>static styles</code>クラスフィールド</a>を使うことを推奨します。
しかし、Litテンプレートでスタイルを定義したい時もあるでしょう。
テンプレートで適用範囲が限定されたスタイルを加える方法は下記の2つです。</p>
<ul>
<li><a class="Link" href="#style要素を使ってスタイルを定義する"><code>&lt;style&gt;</code>要素</a>を使ってスタイルを追加する。</li>
<li><a class="Link" href="#外部のスタイルシートをインポートする(非推奨)">外部のスタイルシート</a>を使ってスタイルを追加する。(非推奨)</li>
</ul>
<p>これらの方法はそれぞれ利点と欠点があります。</p>
<h3 id="style要素を使ってスタイルを定義する"><a href="#style要素を使ってスタイルを定義する">style要素を使ってスタイルを定義する</a></h3>
<p>通常、スタイルは<a class="Link" href="#コンポーネントにスタイルを加える"><code>static styles</code>クラスフィールド</a>に配置されます。
<code>static styles</code>クラスフィールドはクラス毎に1度のみ評価されます。
インスタンス毎にスタイルを設定する必要がある時もあるかもしれません。
For this, we recommend using CSS properties to create <a class="Link" href="#テーマ">themable elements</a>.
Alternatively, you can also include <code>&lt;style&gt;</code> elements in a Lit template.
These are updated per instance.</p>
<pre><code class="language-js">render() {
  return html`
    &lt;style&gt;
      /* updated per instance */
    &lt;/style&gt;
    &lt;div&gt;template content&lt;/div&gt;
  `;
}
</code></pre>
<div class="alert alert-info">

<p><strong>Limitations in the ShadyCSS polyfill around per instance styling.</strong> Per instance styling is not supported using the ShadyCSS polyfill. See the <a class="Link" href="https://github.com/webcomponents/polyfills/tree/master/packages/shadycss#limitations">ShadyCSS limitations</a> for details.</p>
</div>

<h4 id="Expressions_and_style_elements"><a href="#Expressions_and_style_elements">Expressions and style elements</a></h4>
<p>Using expressions inside style elements has some important limitations and performance issues.</p>
<pre><code class="language-js">render() {
  return html`
    &lt;style&gt;
      :host {
        /* Warning: this approach has limitations &amp; performance issues! */
        color: ${myColor}
      }
    &lt;/style&gt;
    &lt;div&gt;template content&lt;/div&gt;
  `;
}
</code></pre>
<div class="alert alert-info">

<p><strong>Limitations in the ShadyCSS polyfill around expressions.</strong> Expressions in <code>&lt;style&gt;</code> elements won't update per instance in ShadyCSS, due to limitations of the ShadyCSS polyfill. In addition, <code>&lt;style&gt;</code> nodes may not be passed as expression values when using the ShadyCSS polyfill. See the <a class="Link" href="https://github.com/webcomponents/polyfills/tree/master/packages/shadycss#limitations">ShadyCSS limitations</a> for more information.</p>
</div>

<p>Evaluating an expression inside a <code>&lt;style&gt;</code> element is extremely inefficient. When any text inside a <code>&lt;style&gt;</code> element changes, the browser must re-parse the whole <code>&lt;style&gt;</code> element, resulting in unnecessary work.</p>
<p>To mitigate this cost, separate styles that require per-instance evaluation from those that don't.</p>
<pre><code class="language-js">  static styles = css`/* ... */`;
  render() {
    const redStyle = html`&lt;style&gt; :host { color: red; } &lt;/style&gt;`;
    return html`${this.red ? redStyle : ''}`
</code></pre>
<h3 id="外部のスタイルシートをインポートする(非推奨)"><a href="#外部のスタイルシートをインポートする(非推奨)">外部のスタイルシートをインポートする(非推奨)</a></h3>
<p>While you can include an external style sheet in your template with a <code>&lt;link&gt;</code>, we do not recommend this approach. Instead, styles should be placed in the <a class="Link" href="#add-styles">static <code>styles</code> class field</a>.</p>
<div class="alert alert-info">

<p><strong>External stylesheet caveats.</strong></p>
<ul>
<li>The <a class="Link" href="https://github.com/webcomponents/polyfills/tree/master/packages/shadycss#limitations">ShadyCSS polyfill</a> doesn't support external style sheets.</li>
<li>External styles can cause a flash-of-unstyled-content (FOUC) while they load.</li>
<li>The URL in the <code>href</code> attribute is relative to the <strong>main document</strong>. This is okay if you're building an app and your asset URLs are well-known, but avoid using external style sheets when building a reusable element.</li>
</ul>
</div>

<h2 id="Dynamic_classes_and_styles"><a href="#Dynamic_classes_and_styles">Dynamic classes and styles</a></h2>
<p>One way to make styles dynamic is to add expressions to the <code>class</code> or <code>style</code> attributes in your template.</p>
<p>Lit offers two directives, <code>classMap</code> and <code>styleMap</code>, to conveniently apply classes and styles in HTML templates.</p>
<p>For more information on these and other directives, see the documentation on <a class="Link" href="https://lit.dev/docs/templates/directives/">built-in directives</a>.</p>
<p>To use <code>styleMap</code> and/or <code>classMap</code>:</p>
<ol>
<li><p>Import <code>classMap</code> and/or <code>styleMap</code>:</p>
<pre><code class="language-js">import { classMap } from 'lit/directives/class-map.js';
import { styleMap } from 'lit/directives/style-map.js';
</code></pre>
</li>
<li><p>Use <code>classMap</code> and/or <code>styleMap</code> in your element template:</p>
</li>
</ol>
<p>{% playground-example "docs/components/style/maps" "my-element.ts" %}</p>
<p>See <a class="Link" href="https://lit.dev/docs/templates/directives/#classmap">classMap</a> and <a class="Link" href="https://lit.dev/docs/templates/directives/#stylemap">styleMap</a> for more information.</p>
<h2 id="テーマ"><a href="#テーマ">テーマ</a></h2>
<p>By using <a class="Link" href="#inheritance">CSS inheritance</a> and <a class="Link" href="#customprops">CSS variables and custom properties</a> together, it's easy to create themable elements. By applying css selectors to customize CSS custom properties, tree-based and per-instance theming is straightforward to apply. Here's an example:</p>
<pre><code class="language-ts">import {LitElement, html, css} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('my-element')
export class MyElement extends LitElement {
  static styles = css`
    :host {
      color: var(--my-element-text-color, black);
      background: var(--my-element-background-color, white);
      font-family: var(--my-element-font-family, Roboto);
      display: block;
      padding: 8px;
      margin: 8px;
    }
  `;
  protected render() {
    return html`&lt;div&gt;Hello World&lt;/div&gt;`;
  }
}
</code></pre>
<h3 id="CSSを継承する"><a href="#CSSを継承する">CSSを継承する</a></h3>
<p>CSS inheritance lets parent and host elements propagate certain CSS properties to their descendants.</p>
<p>Not all CSS properties inherit. Inherited CSS properties include:</p>
<ul>
<li><code>color</code></li>
<li><code>font-family</code> and other <code>font-*</code> properties</li>
<li>All CSS custom properties (<code>--*</code>)</li>
</ul>
<p>See <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/inheritance">CSS Inheritance on MDN</a> for more information.</p>
<p>You can use CSS inheritance to set styles on an ancestor element that are inherited by its descendants:</p>
<pre><code class="language-html">&lt;style&gt;
html {
  color: green;
}
&lt;/style&gt;
&lt;my-element&gt;
  #shadow-root
    Will be green
&lt;/my-element&gt;
</code></pre>
<h3 id="CSS_custom_properties_{#customprops}"><a href="#CSS_custom_properties_{#customprops}">CSS custom properties {#customprops}</a></h3>
<p>All CSS custom properties (<code>--<var>custom-property-name</var></code>) inherit. You can use this to make your component's styles configurable from outside.</p>
<p>The following component sets its background color to a CSS variable. The CSS variable uses the value of <code>--my-background</code> if it's been set by a selector matching an ancestor in the DOM tree, and otherwise defaults to <code>yellow</code>:</p>
<pre><code class="language-js">class MyElement extends LitElement {
  static styles = css`
    :host {
      background-color: var(--my-background, yellow);
    }
  `;
  render() {
    return html`&lt;p&gt;Hello world&lt;/p&gt;`;
  }
}
</code></pre>
<p>Users of this component can set the value of <code>--my-background</code>, using the <code>my-element</code> tag as a CSS selector:</p>
<pre><code class="language-html">&lt;style&gt;
  my-element {
    --my-background: rgb(67, 156, 144);
  }
&lt;/style&gt;
&lt;my-element&gt;&lt;/my-element&gt;
</code></pre>
<p><code>--my-background</code> is configurable per instance of <code>my-element</code>:</p>
<pre><code class="language-html">&lt;style&gt;
  my-element {
    --my-background: rgb(67, 156, 144);
  }
  my-element.stuff {
    --my-background: #111111;
  }
&lt;/style&gt;
&lt;my-element&gt;&lt;/my-element&gt;
&lt;my-element class="stuff"&gt;&lt;/my-element&gt;
</code></pre>
<p>See <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/CSS/--*">CSS Custom Properties on MDN</a> for more information.</p>
<hr>
<h2 id="License"><a href="#License">License</a></h2>
<h3 id="Japanese_part"><a href="#Japanese_part">Japanese part</a></h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by-nc/4.0/legalcode">Creative Commons Attribution-NonCommercial 4.0 International Public License</a></p>
<p>Copyright (c) 2022 38elements</p>
<h3 id="Other"><a href="#Other">Other</a></h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by/3.0/deed.en">Creative Commons Attribution 3.0 Unported</a></p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>BSD 3-Clause License</p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ol>
<li><p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p>
</li>
<li><p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p>
</li>
<li><p>Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.</p>
</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </main>
    <div class="side"></div>
    <div class="side"></div>
    <footer class="footer markdown-body">
      <a href="/lit">Top</a>
    </footer>
    <div class="side"></div>
  </body>
</html>