<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="twitter:card" content="summary" />
    <meta property="og:url" content="https://japanese-document.github.io/lit/components-events.html" />
    <meta property="og:title" content="イベント" />
    <meta property="og:description" content="イベントは要素が変化を伝える標準的な方法です。通常、それらの変化はユーザのインタラクションから発生します。例えば、button要素はユーザにクリックされたときにclickイベントをdispatchします。input要素はユーザが値を入力するとchangeイベントをdispatchします。Litで作ったcustom elementsはこれらの自動的にdispatchされるWeb標準のイベントに加えて、カスタムイベントをdispatchすることができます。例えば、menu要素は項目が変更されたことを示すイベントをdispatchするでしょう。popup要素はポップアップが開いたり閉じたりするときに" />
    <meta property="og:image" content="https://avatars2.githubusercontent.com/u/42838312?s=400" />
    <meta name="theme-color" content="#f1f7fe" />
    <meta name="description" content="イベントは要素が変化を伝える標準的な方法です。通常、それらの変化はユーザのインタラクションから発生します。例えば、button要素はユーザにクリックされたときにclickイベントをdispatchします。input要素はユーザが値を入力するとchangeイベントをdispatchします。Litで作ったcustom elementsはこれらの自動的にdispatchされるWeb標準のイベントに加えて、カスタムイベントをdispatchすることができます。例えば、menu要素は項目が変更されたことを示すイベントをdispatchするでしょう。popup要素はポップアップが開いたり閉じたりするときに" />
    <title>イベント</title>
    <link rel="stylesheet" href="/lit/app.css?v=001" type="text/css"  media="all" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L9VVC74WWF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-L9VVC74WWF');
    </script>
  </head>
  <body class="container">
    <div class="left-side">
    <div class="index-menu">
      <details open="">
        <summary>コンポーネント</summary>
        <p><a href="https://japanese-document.github.io/lit/components-defining.html">定義</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-rendering.html">レンダリング</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-properties.html">リアクティブプロパティ</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-styles.html">スタイル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-lifecycle.html">ライフサイクル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-shadow-dom.html">Shadow DOM</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-events.html">イベント</a></p>
      </details>
      <details open="">
        <summary>テンプレート</summary>
        <p><a href="https://japanese-document.github.io/lit/templates-expressions.html">Expressions</a></p>
      </details>
      <details open="">
        <summary>API</summary>
        <p><a href="https://japanese-document.github.io/lit/api-LitElement.html">LitElement</a></p>
        <p><a href="https://japanese-document.github.io/lit/api-templates.html">テンプレート</a></p>
      </details>
    </div></div>
    <main class="main markdown-body">
      <h1 id="イベント"><a href="#イベント">イベント</a></h1>
<p>イベントは要素が変化を伝える標準的な方法です。
通常、それらの変化はユーザのインタラクションから発生します。
例えば、button要素はユーザにクリックされたときにclickイベントをdispatchします。
input要素はユーザが値を入力するとchangeイベントをdispatchします。</p>
<p>Litで作ったcustom elementsはこれらの自動的にdispatchされるWeb標準のイベントに加えて、カスタムイベントをdispatchすることができます。
例えば、menu要素は項目が変更されたことを示すイベントをdispatchするでしょう。
popup要素はポップアップが開いたり閉じたりするときにイベントをdispatchするでしょう。</p>
<p>JavaScriptのコードはイベントをリッスンしてイベントに紐づいた処理を実行することができます。
例えばtoolbar要素はメニューの項目が選択された時、リストをフィルタリングするでしょう。
login要素はログインボタンがクリックされるとログイン処理を実行するでしょう。</p>
<h2 id="イベントリスニング"><a href="#イベントリスニング">イベントリスニング</a></h2>
<p>LitはWeb標準の<code>addEventListener</code> APIだけでなく、宣言的な方法でも要素にイベントリスナを加えることができます。</p>
<h3 id="テンプレートでイベントリスナを加える"><a href="#テンプレートでイベントリスナを加える">テンプレートでイベントリスナを加える</a></h3>
<p><a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Event_listener_expressions">Event listener expressions</a>を使うとコンポーネントのテンプレートで要素にイベントリスナを加えることができます。
この宣言的な方法で付与されるイベントリスナはテンプレートがレンダリングされる時に要素に加えられます。</p>
<h4 id="イベントリスナのオプションを設定する"><a href="#イベントリスナのオプションを設定する">イベントリスナのオプションを設定する</a></h4>
<p>宣言的な方法で付与されるイベントリスナに(<code>passive</code>や<code>capture</code>のような)オプションを設定するには<code>@eventOptions</code>を使います。
<code>@eventOptions</code>に渡すobjectは<code>addEventListener</code>の<code>options</code>パラメータと同じ役割です。</p>
<pre><code class="language-js">import {LitElement, html} from 'lit';
import {eventOptions} from 'lit/decorators.js';
//...
@eventOptions({passive: true})
private _handleTouchStart(e) { console.log(e.type) }
</code></pre>
<p>デコレータを使う以外にも、
<a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Event_listener_expressions">Event listener expressions</a>にobjectを渡すことで
イベントリスナのオプションを設定することができます。
その渡されるobjectは<code>handleEvent()</code>メソッドと<code>addEventListener()</code>の<code>options</code>引数のキーと値を持ちます。</p>
<pre><code class="language-js">render() {
  return html`&lt;button @click=${{handleEvent: () =&gt; this.onClick(), once: true}}&gt;click&lt;/button&gt;`
}
</code></pre>
<h3 id="コンポーネントもしくはshadow_rootにイベントリスナを追加する"><a href="#コンポーネントもしくはshadow_rootにイベントリスナを追加する">コンポーネントもしくはshadow rootにイベントリスナを追加する</a></h3>
<p>コンポーネントにWeb標準の<code>addEventListener</code>メソッドを使ってコンポーネント自身にイベントリスナを追加します。
詳しくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener()</a>を見てください。</p>
<p>コンポーネントのコンストラクタはコンポーネントにイベントリスナを追加することに適した場所です。</p>
<pre><code class="language-js">constructor() {
  super();
  this.addEventListener('click', (e) =&gt; console.log(e.type, e.target.localName));
}
</code></pre>
<p>コンポーネント自身にイベントリスナを追加することはevent delegationの用途で利用されます。そうすることでコード量を削減したり、パフォーマンスを改善することができます。
詳しくは<a class="Link" href="#Event_delegation">event delegation</a>を見てください。
通常、この用途ではどの要素でイベントが発生したかはeventの<code>target</code>プロパティで判別します。</p>
<p>しかし、コンポーネント自身にイベントリスナを追加すると、そのイベントリスナではコンポーネントのShadow DOMで発生したイベントの<code>target</code>はコンポーネント自身になります。
詳しくは<a class="Link" href="#Shadow_DOMでイベントを扱う">Shadow DOMでイベントを扱う</a>を見てください。</p>
<p>これを回避するには、イベントリスナをコンポーネント自身ではなくコンポーネントのshadow root自身に追加します。
<code>shadowRoot</code>(<code>renderRoot</code>プロパティ)は<code>constructor</code>で使うことができないので、イベントリスナは下記のように<code>createRenderRoot</code>メソッド内で追加します。
この場合、<code>createRenderRoot</code>メソッドは必ずshadow rootを返さなければなりません。</p>
<pre><code>import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

@customElement('my-element')
class MyElement extends LitElement {
  @property() hostName = '';
  @property() shadowName = '';

  constructor() {
    super();
    this.addEventListener('click',
      (e: Event) =&gt; this.hostName = (e.target as Element).localName);
  }

  protected createRenderRoot() {
    const root = super.createRenderRoot();
    root.addEventListener('click',
      (e: Event) =&gt; this.shadowName = (e.target as Element).localName);
    return root;
  }

  protected render() {
    return html`
      &lt;p&gt;&lt;button&gt;Click Me!&lt;/button&gt;&lt;/p&gt;
      &lt;p&gt;Component target: ${this.hostName}&lt;/p&gt;
      &lt;p&gt;Shadow target: ${this.shadowName}&lt;/p&gt;
    `;
  }
}
</code></pre>
<h3 id="他の要素にイベントリスナを追加する"><a href="#他の要素にイベントリスナを追加する">他の要素にイベントリスナを追加する</a></h3>
<p>コンポーネント自身とテンプレートにあるDOM以外の要素(例: <code>window</code>、<code>document</code>、メインのDOMツリー上にある要素)にイベントリスナを追加したい場合、
<code>connectedCallback</code>でイベントリスナを追加します。そして、<code>disconnectedCallback</code>でイベントリスナを削除します。</p>
<ul>
<li><p><code>disconnectedCallback</code>でイベントリスナを削除する処理を記述することは、コンポーネントが破棄されたりページ上から削除された時にコンポーネントがクリーンアップされることを保証します。</p>
</li>
<li><p>(コンストラクタや<code>firstUpdated</code>の代わりに)<code>connectedCallback</code>でイベントリスナを追加する処理を追加することは、コンポーネントがページ上から削除されて後に追加されたときに再びイベントリスナが追加されることを保証します。</p>
</li>
</ul>
<pre><code class="language-js">connectedCallback() {
  super.connectedCallback();
  window.addEventListener('resize', this._handleResize);
}
disconnectedCallback() {
  window.removeEventListener('resize', this._handleResize);
  super.disconnectedCallback();
}
</code></pre>
<p><code>connectedCallback</code> and <code>disconnectedCallback</code>の詳しい情報は<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks">lifecycle callbacks</a>を見てください。</p>
<h3 id="パフォーマンスを改善する"><a href="#パフォーマンスを改善する">パフォーマンスを改善する</a></h3>
<p>Adding event listeners is extremely fast and typically not a performance concern. However, for components that are used in high frequency and need a lot of event listeners, you can optimize first render performance by reducing the number of listeners used via <a class="Link" href="#event-delegation">event delegation</a> and adding listeners <a class="Link" href="#async-events">asynchronously</a> after rendering.</p>
<h4 id="Event_delegation"><a href="#Event_delegation">Event delegation</a></h4>
<p>Using event delegation can reduce the number of event listeners used and therefore improve performance. It is also sometimes convenient to centralize event handling to reduce code. Event delegation can only be use to handle events that <code>bubble</code>. See <a class="Link" href="#dispatching-events">Dispatching events</a> for details on bubbling.</p>
<p>Bubbling events can be heard on any ancestor element in the DOM. You can take advantage of this by adding a single event listener on an ancestor component to be notified of a bubbling event dispatched by any of its descendants in the DOM. Use the event's <code>target</code> property to take specific action based on the element that dispatched the event.</p>
<p>{% playground-example "docs/components/events/delegation/" "my-element.ts" %}</p>
<h4 id="Asynchronously_adding_event_listeners_{_#async-events_}"><a href="#Asynchronously_adding_event_listeners_{_#async-events_}">Asynchronously adding event listeners { #async-events }</a></h4>
<p>To add an event listener after rendering, use the <code>firstUpdated</code> method. This is a Lit lifecycle callback which runs after the component first updates and renders its templated DOM.</p>
<p>The <code>firstUpdated</code> callback fires after the first time your component has been updated and called its <code>render</code> method, but <strong>before</strong> the browser has had a chance to paint.</p>
<p>See <a class="Link" href="/docs/components/lifecycle/#firstupdated">firstUpdated</a> in the Lifecycle documentation for more information.</p>
<p>To ensure the listener is added after the user can see the component, you can await a Promise that resolves after the browser paints.</p>
<pre><code class="language-js">async firstUpdated() {
  // Give the browser a chance to paint
  await new Promise((r) =&gt; setTimeout(r, 0));
  this.addEventListener('click', this._handleClick);
}
</code></pre>
<h3 id="Understanding_this_in_event_listeners"><a href="#Understanding_this_in_event_listeners">Understanding <code>this</code> in event listeners</a></h3>
<p>Event listeners added using the declarative <code>@</code> syntax in the template are automatically <em>bound</em> to the component.</p>
<p>Therefore, you can use <code>this</code> to refer to your component instance inside any declarative event handler:</p>
<pre><code class="language-js">class MyElement extends LitElement {
  render() {
    return html`&lt;button @click="${this._handleClick}"&gt;click&lt;/button&gt;`;
  }
  _handleClick(e) {
    console.log(this.prop);
  }
}
</code></pre>
<p>When adding listeners imperatively with <code>addEventListener</code>, you'll want to use an arrow function so that <code>this</code> refers to the component:</p>
<pre><code class="language-ts">export class MyElement extends LitElement {
  private _handleResize = () =&gt; {
    // `this` refers to the component
    console.log(this.isConnected);
  }

  constructor() {
    window.addEventListener('resize', this._handleResize);
  }
}
</code></pre>
<p>See the <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">documentation for <code>this</code> on MDN</a> for more information.</p>
<h3 id="Listening_to_events_fired_from_repeated_templates"><a href="#Listening_to_events_fired_from_repeated_templates">Listening to events fired from repeated templates</a></h3>
<p>When listening to events on repeated items, it's often convenient to use <a class="Link" href="#event-delegation">event delegation</a> if the event bubbles. When an event does not bubble, a listener can be added on the repeated elements. Here's an example of both methods:</p>
<p>{% playground-example "docs/components/events/list/" "my-element.ts" %}</p>
<h2 id="Dispatching_events_{_#dispatching-events_}"><a href="#Dispatching_events_{_#dispatching-events_}">Dispatching events { #dispatching-events }</a></h2>
<p>All DOM nodes can dispatch events using the <code>dispatchEvent</code> method. First, create an event instance, specifying the event type and options. Then pass it to <code>dispatchEvent</code> as follows:</p>
<pre><code class="language-js">const event = new Event('my-event', {bubbles: true, composed: true});
myElement.dispatchEvent(event);
</code></pre>
<p>The <code>bubbles</code> option allows the event to flow up the DOM tree to ancestors of the dispatching element. It's important to set this flag if you want the event to be able to participate in <a class="Link" href="#event-delegation">event delegation</a>.</p>
<p>The <code>composed</code> option is useful to set to allow the event to be dispatched above the shadow DOM tree in which the element exists.</p>
<p>See <a class="Link" href="#shadowdom">Working with events in shadow DOM</a> for more information.</p>
<p>See <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent">EventTarget.dispatchEvent()</a> on MDN for a full description of dispatching events.</p>
<h3 id="When_to_dispatch_an_event"><a href="#When_to_dispatch_an_event">When to dispatch an event</a></h3>
<p>Events should be dispatched in response to user interaction or asynchronous changes in the component's state. They should generally <strong>not</strong> be dispatched in response to state changes made by the owner of the component via its property or attribute APIs. This is generally how native web platform elements work.</p>
<p>For example, when a user types a value into an <code>input</code> element a <code>change</code> event is dispatched, but if code sets the <code>input</code>'s <code>value</code> property, a <code>change</code> event is <strong>not</strong> dispatched.</p>
<p>Similarly, a menu component should dispatch an event when the user selects a menu item, but it should not dispatch an event if, for example, the menu's <code>selectedItem</code> property is set.</p>
<p>This typically means that a component should dispatch an event in response to another event to which it is listening.</p>
<p>{% playground-ide "docs/components/events/dispatch/" "my-dispatcher.ts" %}</p>
<h3 id="Dispatching_events_after_an_element_updates"><a href="#Dispatching_events_after_an_element_updates">Dispatching events after an element updates</a></h3>
<p>Often, an event should be fired only after an element updates and renders. This might be necessary if an event is intended to communicate a change in rendered state based on user interaction. In this case, the component's <code>updateComplete</code> Promise can be awaited after changing state, but before dispatching the event.</p>
<p>{% playground-ide "docs/components/events/update/" "my-dispatcher.ts" %}</p>
<h3 id="Using_standard_or_custom_events_{_#standard-custom-events_}"><a href="#Using_standard_or_custom_events_{_#standard-custom-events_}">Using standard or custom events { #standard-custom-events }</a></h3>
<p>Events can be dispatched either by constructing an <code>Event</code> or a <code>CustomEvent</code>. Either is a reasonable approach. When using a <code>CustomEvent</code>, any event data is passed in the event's <code>detail</code> property. When using an <code>Event</code>, an event subclass can be made and custom API attached to it.</p>
<p>See <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event">Event</a> on MDN for details about constructing events.</p>
<h4 id="Firing_a_custom_event_"><a href="#Firing_a_custom_event_">Firing a custom event:</a></h4>
<pre><code class="language-js">const event = new CustomEvent('my-event', {
  detail: {
    message: 'Something important happened'
  }
});
this.dispatchEvent(event);
</code></pre>
<p>See the <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent">MDN documentation on custom events</a> for more information.</p>
<h4 id="Firing_a_standard_event_"><a href="#Firing_a_standard_event_">Firing a standard event:</a></h4>
<pre><code class="language-js">class MyEvent extends Event {
  constructor(message) {
    super();
    this.type = 'my-event';
    this.message = message;
  }
}

const event = new MyEvent('Something important happened');
this.dispatchEvent(event);
</code></pre>
<h2 id="Shadow_DOMでイベントを扱う"><a href="#Shadow_DOMでイベントを扱う">Shadow DOMでイベントを扱う</a></h2>
<p>When using shadow DOM there are a few modifications to the standard event system that are important to understand. Shadow DOM exists primarily to provide a scoping mechanism in the DOM that encapsulates details about these "shadow" elements. As such, events in shadow DOM encapsulate certain details from outside DOM elements.</p>
<h3 id="Understanding_composed_event_dispatching_{#shadowdom-composed}"><a href="#Understanding_composed_event_dispatching_{#shadowdom-composed}">Understanding composed event dispatching {#shadowdom-composed}</a></h3>
<p>By default, an event dispatched inside a shadow root will not be visible outside that shadow root. To make an event pass through shadow DOM boundaries, you must set the <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/composed"><code>composed</code> property</a> to <code>true</code>. It's common to pair <code>composed</code> with <code>bubbles</code> so that all nodes in the DOM tree can see the event:</p>
<pre><code class="language-js">_dispatchMyEvent() {
  let myEvent = new CustomEvent('my-event', {
    detail: { message: 'my-event happened.' },
    bubbles: true,
    composed: true });
  this.dispatchEvent(myEvent);
}
</code></pre>
<p>If an event is <code>composed</code> and does <code>bubble</code>, it can be received by all ancestors of the element that dispatches the event—including ancestors in outer shadow roots. If an event is <code>composed</code> but does not <code>bubble</code>, it can only be received on the element that dispatches the event and on the host element containing the shadow root.</p>
<p>Note that most standard user interface events, including all mouse, touch, and keyboard events, are both bubbling and composed. See the <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/composed">MDN documentation on composed events</a> for more information.</p>
<h3 id="Understanding_event_retargeting_{#shadowdom-retargeting}"><a href="#Understanding_event_retargeting_{#shadowdom-retargeting}">Understanding event retargeting {#shadowdom-retargeting}</a></h3>
<p><a class="Link" href="#shadowdom-composed">Composed</a> events dispatched from within a shadow root are retargeted, meaning that to any listener on an element hosting a shadow root or any of its ancestors, they appear to come from the hosting element. Since Lit components render into shadow roots, all composed events dispatched from inside a Lit component appear to be dispatched by the Lit component itself. The event's <code>target</code> property is the Lit component.</p>
<pre><code class="language-html">&lt;my-element onClick="(e) =&gt; console.log(e.target)"&gt;&lt;/my-element&gt;
</code></pre>
<pre><code class="language-js">render() {
  return html`
    &lt;button id="mybutton" @click="${(e) =&gt; console.log(e.target)}"&gt;
      click me
    &lt;/button&gt;`;
}
</code></pre>
<p>In advanced cases where it is required to determine the origin of an event, use the <code>event.composedPath()</code> API. This method returns an array of all the nodes traversed by the event dispatch, including those within shadow roots. Because this breaks encapsulation, care should be taken to avoid relying on implementation details that may be exposed.  Common use cases include determining if the element clicked was an anchor tag, for purposes of client-side routing.</p>
<pre><code class="language-js">handleMyEvent(event) {
  console.log('Origin: ', event.composedPath()[0]);
}
</code></pre>
<p>See the <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath">MDN documentation on composedPath</a> for more information.</p>
<h2 id="Communicating_between_the_event_dispatcher_and_listener"><a href="#Communicating_between_the_event_dispatcher_and_listener">Communicating between the event dispatcher and listener</a></h2>
<p>Events exist primarily to communicate changes from the event dispatcher to the event listener, but events can also be used to communicate information from the listener back to the dispatcher.</p>
<p>One way you can do this is to expose API on events which listeners can use to customize component behavior. For example, a listener can set a property on a custom event's detail property which the dispatching component then uses to customize behavior.</p>
<p>Another way to communicate between the dispatcher and listener is via the <code>preventDefault()</code> method. It can be called to indicate the event's standard action should not occur. When the listener calls <code>preventDefault()</code>, the event's <code>defaultPrevented</code> property becomes true. This flag can then be used by the listener to customize behavior.</p>
<p>Both of these techniques are used in the following example:</p>
<p>{% playground-ide "docs/components/events/comm/" "my-listener.ts" %}</p>

    </main>
    <div class="right-side"><div class="header-list"><p class="h1"><a href="#イベント">イベント</a></p>
<p class="h2"><a href="#イベントリスニング">イベントリスニング</a></p>
<p class="h3"><a href="#テンプレートでイベントリスナを加える">テンプレートでイベントリスナを加える</a></p>
<p class="h4"><a href="#イベントリスナのオプションを設定する">イベントリスナのオプションを設定する</a></p>
<p class="h3"><a href="#コンポーネントもしくはshadow_rootにイベントリスナを追加する">コンポーネントもしくはshadow rootにイベントリスナを追加する</a></p>
<p class="h3"><a href="#他の要素にイベントリスナを追加する">他の要素にイベントリスナを追加する</a></p>
<p class="h3"><a href="#パフォーマンスを改善する">パフォーマンスを改善する</a></p>
<p class="h4"><a href="#Event_delegation">Event delegation</a></p>
<p class="h4"><a href="#Asynchronously_adding_event_listeners_{_#async-events_}">Asynchronously adding event listeners { #async-events }</a></p>
<p class="h3"><a href="#Understanding_this_in_event_listeners">Understanding this in event listeners</a></p>
<p class="h3"><a href="#Listening_to_events_fired_from_repeated_templates">Listening to events fired from repeated templates</a></p>
<p class="h2"><a href="#Dispatching_events_{_#dispatching-events_}">Dispatching events { #dispatching-events }</a></p>
<p class="h3"><a href="#When_to_dispatch_an_event">When to dispatch an event</a></p>
<p class="h3"><a href="#Dispatching_events_after_an_element_updates">Dispatching events after an element updates</a></p>
<p class="h3"><a href="#Using_standard_or_custom_events_{_#standard-custom-events_}">Using standard or custom events { #standard-custom-events }</a></p>
<p class="h4"><a href="#Firing_a_custom_event_">Firing a custom event:</a></p>
<p class="h4"><a href="#Firing_a_standard_event_">Firing a standard event:</a></p>
<p class="h2"><a href="#Shadow_DOMでイベントを扱う">Shadow DOMでイベントを扱う</a></p>
<p class="h3"><a href="#Understanding_composed_event_dispatching_{#shadowdom-composed}">Understanding composed event dispatching {#shadowdom-composed}</a></p>
<p class="h3"><a href="#Understanding_event_retargeting_{#shadowdom-retargeting}">Understanding event retargeting {#shadowdom-retargeting}</a></p>
<p class="h2"><a href="#Communicating_between_the_event_dispatcher_and_listener">Communicating between the event dispatcher and listener</a></p></div></div>
    <footer class="footer markdown-body">
      <a href="/lit">Top</a>
    </footer>
  </body>
</html>