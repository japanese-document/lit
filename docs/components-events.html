<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="twitter:card" content="summary" />
    <meta property="og:url" content="https://japanese-document.github.io/lit/components-events.html" />
    <meta property="og:title" content="イベント" />
    <meta property="og:description" content="イベントは要素が変化を伝える標準的な方法です。通常、それらの変化はユーザのインタラクションから発生します。例えば、button要素はユーザにクリックされたときにclickイベントをdispatchします。input要素はユーザが値を入力するとchangeイベントをdispatchします。Litで作ったcustom elementsはこれらの自動的にdispatchされるWeb標準のイベントに加えて、カスタムイベントをdispatchすることができます。例えば、menu要素は項目が変更されたことを示すイベントをdispatchするでしょう。popup要素はポップアップが開いたり閉じたりするときに" />
    <meta property="og:image" content="https://avatars2.githubusercontent.com/u/42838312?s=400" />
    <meta name="theme-color" content="#f1f7fe" />
    <meta name="description" content="イベントは要素が変化を伝える標準的な方法です。通常、それらの変化はユーザのインタラクションから発生します。例えば、button要素はユーザにクリックされたときにclickイベントをdispatchします。input要素はユーザが値を入力するとchangeイベントをdispatchします。Litで作ったcustom elementsはこれらの自動的にdispatchされるWeb標準のイベントに加えて、カスタムイベントをdispatchすることができます。例えば、menu要素は項目が変更されたことを示すイベントをdispatchするでしょう。popup要素はポップアップが開いたり閉じたりするときに" />
    <meta name="Hatena::Bookmark" content="nocomment" />
    <title>イベント</title>
    <link rel="icon" type="image/png" href="/lit/images/favicon.png" />
    <link rel="stylesheet" href="/lit/app.css?v=001" type="text/css"  media="all" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L9VVC74WWF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-L9VVC74WWF');
    </script>
  </head>
  <body class="container">
    <div class="left-side">
    <nav class="index-menu">
      <details open="">
        <summary>コンポーネント</summary>
        <p><a href="https://japanese-document.github.io/lit/components-defining.html">定義</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-rendering.html">レンダリング</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-properties.html">リアクティブプロパティ</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-styles.html">スタイル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-lifecycle.html">ライフサイクル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-shadow-dom.html">Shadow DOM</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-events.html">イベント</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-decorators.html">デコレータ</a></p>
      </details>
      <details open="">
        <summary>テンプレート</summary>
        <p><a href="https://japanese-document.github.io/lit/templates-expressions.html">エクスプレッション</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-conditionals.html">条件</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-lists.html">リスト</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-directives.html">ビルトインディレクティブ</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-custom-directives.html">カスタムディレクティブ</a></p>
      </details>
      <details open="">
        <summary>組み合わせ</summary>
        <p><a href="https://japanese-document.github.io/lit/composition-component.html">コンポーネントを組み合わせる</a></p>
        <p><a href="https://japanese-document.github.io/lit/composition-controllers.html">リアクティブコントローラ</a></p>
      </details>
      <details open="">
        <summary>API</summary>
        <p><a href="https://japanese-document.github.io/lit/api-LitElement.html">LitElement</a></p>
        <p><a href="https://japanese-document.github.io/lit/api-templates.html">テンプレート</a></p>
      </details>
    </nav></div>
    <main class="main markdown-body">
      <h1 id="イベント"><a class="anchor" href="#イベント">#</a>イベント</h1>
<p>イベントは要素が変化を伝える標準的な方法です。
通常、それらの変化はユーザのインタラクションから発生します。
例えば、button要素はユーザにクリックされたときにclickイベントをdispatchします。
input要素はユーザが値を入力するとchangeイベントをdispatchします。</p>
<p>Litで作ったcustom elementsはこれらの自動的にdispatchされるWeb標準のイベントに加えて、カスタムイベントをdispatchすることができます。
例えば、menu要素は項目が変更されたことを示すイベントをdispatchするでしょう。
popup要素はポップアップが開いたり閉じたりするときにイベントをdispatchするでしょう。</p>
<p>JavaScriptのコードはイベントをリッスンしてイベントに紐づいた処理を実行することができます。
例えばtoolbar要素はメニューの項目が選択された時、リストをフィルタリングするでしょう。
login要素はログインボタンがクリックされるとログイン処理を実行するでしょう。</p>
<h2 id="イベントリスニング"><a class="anchor" href="#イベントリスニング">#</a>イベントリスニング</h2>
<p>LitはWeb標準の<code>addEventListener</code> APIだけでなく、宣言的な方法でも要素にイベントリスナを加えることができます。</p>
<h3 id="テンプレートでイベントリスナを加える"><a class="anchor" href="#テンプレートでイベントリスナを加える">#</a>テンプレートでイベントリスナを加える</h3>
<p><a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Event_listener_expressions">Event listener expressions</a>を使うとコンポーネントのテンプレートで要素にイベントリスナを加えることができます。
この宣言的な方法で付与されるイベントリスナはテンプレートがレンダリングされる時に要素に加えられます。</p>
<h4 id="イベントリスナのオプションを設定する"><a class="anchor" href="#イベントリスナのオプションを設定する">#</a>イベントリスナのオプションを設定する</h4>
<p>宣言的な方法で付与されるイベントリスナに(<code>passive</code>や<code>capture</code>のような)オプションを設定するには<code>@eventOptions</code>を使います。
<code>@eventOptions</code>に渡すobjectは<code>addEventListener</code>の<code>options</code>パラメータと同じ役割です。</p>
<pre><code class="language-js">import {LitElement, html} from 'lit';
import {eventOptions} from 'lit/decorators.js';
//...
@eventOptions({passive: true})
private _handleTouchStart(e) { console.log(e.type) }
</code></pre>
<p>デコレータを使う以外にも、
<a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Event_listener_expressions">Event listener expressions</a>にobjectを渡すことで
イベントリスナのオプションを設定することができます。
その渡されるobjectは<code>handleEvent()</code>メソッドと<code>addEventListener()</code>の<code>options</code>引数のキーと値を持ちます。</p>
<pre><code class="language-js">render() {
  return html`&lt;button @click=${{handleEvent: () =&gt; this.onClick(), once: true}}&gt;click&lt;/button&gt;`
}
</code></pre>
<h3 id="コンポーネントもしくはshadow_rootにイベントリスナを追加する"><a class="anchor" href="#コンポーネントもしくはshadow_rootにイベントリスナを追加する">#</a>コンポーネントもしくはshadow rootにイベントリスナを追加する</h3>
<p>コンポーネントにWeb標準の<code>addEventListener</code>メソッドを使ってコンポーネント自身にイベントリスナを追加します。
詳しくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener">EventTarget.addEventListener()</a>を見てください。</p>
<p>コンポーネントのコンストラクタはコンポーネントにイベントリスナを追加することに適した場所です。</p>
<pre><code class="language-js">constructor() {
  super();
  this.addEventListener('click', (e) =&gt; console.log(e.type, e.target.localName));
}
</code></pre>
<p>コンポーネント自身にイベントリスナを追加することはevent delegationの用途で利用されます。そうすることでコード量を削減したり、パフォーマンスを改善することができます。
詳しくは<a class="Link" href="#Event_delegation">event delegation</a>を見てください。
通常、この用途ではどの要素でイベントが発生したかはeventの<code>target</code>プロパティで判別します。</p>
<p>しかし、コンポーネント自身にイベントリスナを追加すると、そのイベントリスナではコンポーネントのShadow DOMで発生したイベントの<code>target</code>はコンポーネント自身になります。
詳しくは<a class="Link" href="#Shadow_DOMでイベントを扱う">Shadow DOMでイベントを扱う</a>を見てください。</p>
<p>これを回避するには、イベントリスナをコンポーネント自身ではなくコンポーネントのshadow root自身に追加します。
<code>shadowRoot</code>(<code>renderRoot</code>プロパティ)は<code>constructor</code>で使うことができないので、イベントリスナは下記のように<code>createRenderRoot</code>メソッド内で追加します。
この場合、<code>createRenderRoot</code>メソッドは必ずshadow rootを返さなければなりません。</p>
<pre><code>import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

@customElement('my-element')
class MyElement extends LitElement {
  @property() hostName = '';
  @property() shadowName = '';

  constructor() {
    super();
    this.addEventListener('click',
      (e: Event) =&gt; this.hostName = (e.target as Element).localName);
  }

  protected createRenderRoot() {
    const root = super.createRenderRoot();
    root.addEventListener('click',
      (e: Event) =&gt; this.shadowName = (e.target as Element).localName);
    return root;
  }

  protected render() {
    return html`
      &lt;p&gt;&lt;button&gt;Click Me!&lt;/button&gt;&lt;/p&gt;
      &lt;p&gt;Component target: ${this.hostName}&lt;/p&gt;
      &lt;p&gt;Shadow target: ${this.shadowName}&lt;/p&gt;
    `;
  }
}
</code></pre>
<h3 id="他の要素にイベントリスナを追加する"><a class="anchor" href="#他の要素にイベントリスナを追加する">#</a>他の要素にイベントリスナを追加する</h3>
<p>コンポーネント自身とテンプレートにあるDOM以外の要素(例: <code>window</code>、<code>document</code>、メインのDOMツリー上にある要素)にイベントリスナを追加したい場合、
<code>connectedCallback</code>でイベントリスナを追加します。そして、<code>disconnectedCallback</code>でイベントリスナを削除します。</p>
<ul>
<li><p><code>disconnectedCallback</code>でイベントリスナを削除する処理を記述することは、コンポーネントが破棄されたりページ上から削除された時にコンポーネントがクリーンアップされることを保証します。</p>
</li>
<li><p>(コンストラクタや<code>firstUpdated</code>の代わりに)<code>connectedCallback</code>でイベントリスナを追加する処理を追加することは、コンポーネントがページ上から削除されて後に追加されたときに再びイベントリスナが追加されることを保証します。</p>
</li>
</ul>
<pre><code class="language-js">connectedCallback() {
  super.connectedCallback();
  window.addEventListener('resize', this._handleResize);
}
disconnectedCallback() {
  window.removeEventListener('resize', this._handleResize);
  super.disconnectedCallback();
}
</code></pre>
<p><code>connectedCallback</code> and <code>disconnectedCallback</code>の詳しい情報は<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#Using_the_lifecycle_callbacks">lifecycle callbacks</a>を見てください。</p>
<h3 id="パフォーマンスの向上"><a class="anchor" href="#パフォーマンスの向上">#</a>パフォーマンスの向上</h3>
<p>通常、イベントリスナを追加する処理はとても高速なので、パフォーマンス上の問題になりません。
しかし、高頻度で使用され、多くのイベントリスナを持つコンポーネントでは、
<a class="Link" href="#Event_delegation">event delegation</a>を使ってイベントリスナを削減してレンダリング後に<a class="Link" href="#非同期でイベントリスナを追加する">非同期でイベントリスナを追加する</a>ことで初回レンダリングのパフォーマンスを向上させることができます。</p>
<h4 id="Event_delegation"><a class="anchor" href="#Event_delegation">#</a>Event delegation</h4>
<p>event delegationを用いるとイベントリスナーを削減することができるのでパフォーマンスを向上させることができます。
また、イベントの処理を集約することができるのでコードを削減することができます。
Event delegationはイベントバブリング時のみを取り扱います。
詳しくは<a class="Link" href="#イベントをdispatchする">イベントをdispatchする</a>を見てください。</p>
<p>イベントバブリング時はイベントが発生した要素の祖先の要素にイベントが伝播します。
このことを利用するには祖先の要素にイベントリスナを追加して、どの子孫要素からバブリングによってイベントがdispatchされたか知る必要があります。
<code>Event</code>インスタンスの<code>target</code>プロパティでどの子孫要素からイベントがdispatchされたか特定することができます。</p>
<h4 id="非同期でイベントリスナを追加する"><a class="anchor" href="#非同期でイベントリスナを追加する">#</a>非同期でイベントリスナを追加する</h4>
<p>レンダリング後にイベントリスナを追加するには、<code>firstUpdated</code>メソッドを使います。
これはコンポーネントの初回に更新でテンプレートが最初にレンダリングされた後に実行されるLitのライフサイクルコールバックです。</p>
<p><code>firstUpdated</code>コールバックはコンポーネントの初回の更新で<code>render</code>メソッドを実行した後とブラウザが描画する前の間に実行されます。
詳しくは<a class="Link" href="https://japanese-document.github.io/lit/components-lifecycle.html#firstUpdated()">firstUpdated</a>を見てください。</p>
<p>コンポーネントが表示された後にイベントリスナを追加するには、下記のようにブラウザが描画した後に解決するPromiseをawaitします。</p>
<pre><code class="language-js">async firstUpdated() {
  // ブラウザの描画処理に譲る
  await new Promise((r) =&gt; setTimeout(r, 0));
  this.addEventListener('click', this._handleClick);
}
</code></pre>
<h3 id="イベントリスナのthis"><a class="anchor" href="#イベントリスナのthis">#</a>イベントリスナの<code>this</code></h3>
<p>テンプレート内で<a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Event_listener_expressions">Event listener expressions</a>(<code>@</code>)を使って宣言的に追加されたイベントリスナは自動的にコンポーネントがbindされます。</p>
<p>だから、下記のように宣言的に追加されたイベントハンドラでは<code>this</code>でコンポーネントインスタンスを参照することができます。</p>
<pre><code class="language-js">class MyElement extends LitElement {
  render() {
    return html`&lt;button @click="${this._handleClick}"&gt;click&lt;/button&gt;`;
  }
  _handleClick(e) {
    console.log(this.prop);
  }
}
</code></pre>
<p><code>addEventListener</code>を使ってイベントリスナを追加する場合、下記のように<code>this</code>でコンポーネントを参照するためにアロー関数を使う必要があります。</p>
<pre><code class="language-ts">export class MyElement extends LitElement {
  private _handleResize = () =&gt; {
    // thisはコンポーネントを参照する
    console.log(this.isConnected);
  }

  constructor() {
    window.addEventListener('resize', this._handleResize);
  }
}
</code></pre>
<p>詳しくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this">thisのドキュメント</a>を見てください。</p>
<h3 id="ループするテンプレートでイベントを取り扱う"><a class="anchor" href="#ループするテンプレートでイベントを取り扱う">#</a>ループするテンプレートでイベントを取り扱う</h3>
<p>下記のように、テンプレートでループを使って要素を生成する場合、イベントバブリングを利用して<a class="Link" href="#Event_delegation">event delegation</a>を使うと便利です。
イベントバブリングしないイベント(focus)の場合、ループで生成される各要素にイベントリスナを加えます。</p>
<pre><code class="language-ts">import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

@customElement('my-element')
class MyElement extends LitElement {
  @property() clicked = '';
  @property() focused = '';
  data = [1, 2, 3];

  protected render() {
    return html`
      &lt;div key="container" @click=${this._clickHandler}&gt;
        ${this.data.map(i =&gt; html`
          &lt;button key=${i} @focus=${this._focusHandler}&gt;Item ${i}&lt;/button&gt;
        `)}
      &lt;/div&gt;
      &lt;p&gt;Clicked: ${this.clicked}&lt;/p&gt;
      &lt;p&gt;Focused: ${this.focused}&lt;/p&gt;
    `;
  }

  private _clickHandler(e: Event) {
    this.clicked = (e.target as Element).getAttribute('key')!;
  }

  private _focusHandler(e: Event) {
    this.focused = (e.target as Element).textContent!;
  }
}
</code></pre>
<h3 id="イベントリスナを削除する"><a class="anchor" href="#イベントリスナを削除する">#</a>イベントリスナを削除する</h3>
<p><code>null</code>、<code>undefined</code>、<code>nothing</code>を<a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Event_listener_expressions">Event listener expressions</a>に渡すと、既存のイベントリスナは削除されます。</p>
<h2 id="イベントをdispatchする"><a class="anchor" href="#イベントをdispatchする">#</a>イベントをdispatchする</h2>
<p>すべてのDOM Nodeは<code>dispatchEvent</code>メソッドでイベントをdispatchすることができます。
下記のように、第1引数にイベントタイプと第2引数にオプションを指定してEventインスタンスを生成します。
それを<code>dispatchEvent</code>に渡します。</p>
<pre><code class="language-js">const event = new Event('my-event', {bubbles: true, composed: true});
myElement.dispatchEvent(event);
</code></pre>
<p><a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event#values">bubbles</a>オプションに<code>true</code>をセットするとイベントをdispatchした要素の先祖方向にイベントが伝播します。
この設定をしないと<a class="Link" href="#Event_delegation">event delegation</a>を行うことができません。</p>
<p><code>composed</code>オプションを<code>true</code>にするとイベントをdispatchした要素が所属しているShadow DOMツリーの外にもイベントが伝播します。</p>
<p>詳しくは<a class="Link" href="#Shadow_DOMでイベントを扱う">Shadow DOMでイベントを扱う</a>と<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent">EventTarget.dispatchEvent()</a>を見てください。</p>
<h3 id="どんなときイベントをdispatchするべきか"><a class="anchor" href="#どんなときイベントをdispatchするべきか">#</a>どんなときイベントをdispatchするべきか</h3>
<p>イベントのdispatchはユーザの操作もしくはコンポーネントのステート(state)の非同期的な変更時に実行されるべきです。
Webのネイティブ要素がそうであるように、コードでコンポーネントのプロパティもしくは属性を変更した時にイベントをdispatchするべきではありません。</p>
<p>例えば、input要素にユーザが入力したら<code>change</code>イベントがdispatchされます。
しかし、コードで<code>input</code>要素の<code>value</code>プロパティを変更した場合、<code>change</code>イベントはdispatchされません。</p>
<p>同様にメニューコンポーネントはメニューの項目が選択されたときはイベントがdispatchされるべきです。メニューコンポーネントの<code>selectedItem</code>プロパティがセットされた場合はイベントをdispatchするべきではありません。</p>
<p>通常、コンポーネントがリスニングしているイベントに応じてそれに適した別のイベントをdispatchするべきです。</p>
<pre><code class="language-ts">import {LitElement, html} from 'lit';
import {customElement, query} from 'lit/decorators.js';

@customElement('my-dispatcher')
class MyDispatcher extends LitElement {
  @query('input', true) _input!: HTMLInputElement;

  protected render() {
    return html`
      &lt;p&gt;Name: &lt;input&gt;&lt;/p&gt;
      &lt;p&gt;&lt;button @click=${this._dispatchLogin}&gt;Login&lt;/button&gt;&lt;/p&gt;
    `;
  }

  private _dispatchLogin() {
    const name = this._input.value.trim();
    if (name) {
      const options = {
        detail: {name},
        bubbles: true,
        composed: true
      };
      this.dispatchEvent(new CustomEvent('mylogin', options));
    }
  }
}
</code></pre>
<pre><code class="language-ts">import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

@customElement('my-listener')
class MyListener extends LitElement {
  @property() name = '';

  protected render() {
    return html`
      &lt;p @mylogin=${this._loginListener}&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/p&gt;
      &lt;p&gt;Login: ${this.name}&lt;/p&gt;`;
  }

  private _loginListener(e: CustomEvent) {
    this.name = e.detail.name;
  }
}
</code></pre>
<pre><code class="language-html">&lt;script type="module" src="./my-listener.js"&gt;&lt;/script&gt;
&lt;script type="module" src="./my-dispatcher.js"&gt;&lt;/script&gt;

&lt;my-listener&gt;
  &lt;my-dispatcher&gt;&lt;/my-dispatcher&gt;
&lt;/my-listener&gt;
</code></pre>
<h3 id="要素の更新の後にイベントをdispatchする"><a class="anchor" href="#要素の更新の後にイベントをdispatchする">#</a>要素の更新の後にイベントをdispatchする</h3>
<p>ほとんどの場合、イベントは要素の更新とレンダリングの後に発生するべきです。
これはユーザの操作から生じたレンダリング結果の変化を伝播するためのイベントの場合は必須です。
この場合、ステートの変更の後、イベントをdispatchする前にコンポーネントの<code>updateComplete</code> Promiseをawaitします。</p>
<pre><code class="language-ts">import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

@customElement('my-dispatcher')
class MyDispatcher extends LitElement {
  @property({type: Boolean}) open = true;

  protected render() {
    return html`
      &lt;p&gt;&lt;button @click=${this._notify}&gt;${this.open ? 'Close' : 'Open'}&lt;/button&gt;&lt;/p&gt;
      &lt;p ?hidden=${!this.open}&gt;Content!&lt;/p&gt;
    `;
  }

  private async _notify() {
    this.open = !this.open;
    await this.updateComplete;
    const name = this.open ? 'opened' : 'closed';
    this.dispatchEvent(new CustomEvent(name, {bubbles: true, composed: true}));
  }
}
</code></pre>
<pre><code class="language-ts">import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

@customElement('my-listener')
class MyListener extends LitElement {
  @property({type: Number}) height: number|null = null;

  protected render() {
    return html`
      &lt;p @opened=${this._listener} @closed=${this._listener}&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/p&gt;
      &lt;p&gt;Height: ${this.height}px&lt;/p&gt;`;
  }

  private _listener() {
    this.height = null;
  }

  protected updated() {
    if (this.height === null) {
      requestAnimationFrame(() =&gt; this.height = this.getBoundingClientRect().height);
    }
  }
}
</code></pre>
<pre><code class="language-html">&lt;script type="module" src="./my-listener.js"&gt;&lt;/script&gt;
&lt;script type="module" src="./my-dispatcher.js"&gt;&lt;/script&gt;

&lt;my-listener&gt;
  &lt;my-dispatcher&gt;&lt;/my-dispatcher&gt;
&lt;/my-listener&gt;
</code></pre>
<h3 id="EventとCustomEventを扱う"><a class="anchor" href="#EventとCustomEventを扱う">#</a>EventとCustomEventを扱う</h3>
<p>イベントは<code>Event</code>もしくは<code>CustomEvent</code>です。どちらを使っても良いです。
<code>CustomEvent</code>を使う場合、イベントのデータは<code>detail</code>プロパティにセットします。
<code>Event</code>を使う場合、<code>Event</code>クラスのサブクラスを作成します。そして、それにAPIを追加します。</p>
<p>詳しくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/Event">Event</a>と<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent">CustomEvent</a>を見てください。</p>
<h4 id="CustomEventの使い方"><a class="anchor" href="#CustomEventの使い方">#</a>CustomEventの使い方</h4>
<pre><code class="language-js">const event = new CustomEvent('my-event', {
  detail: {
    message: 'Something important happened'
  }
});

this.dispatchEvent(event);
</code></pre>
<h4 id="Eventの使い方"><a class="anchor" href="#Eventの使い方">#</a>Eventの使い方</h4>
<pre><code class="language-js">class MyEvent extends Event {
  constructor(message) {
    super();
    this.type = 'my-event';
    this.message = message;
  }
}

const event = new MyEvent('Something important happened');
this.dispatchEvent(event);
</code></pre>
<h2 id="Shadow_DOMでイベントを扱う"><a class="anchor" href="#Shadow_DOMでイベントを扱う">#</a>Shadow DOMでイベントを扱う</h2>
<p>Shadow DOMでイベントを取り扱う場合の注意点があります。
Shadow DOMはshadow要素に関する詳細を外部に公開せずカプセル化します。
Shadow DOMから生じたイベントはshadow要素の詳細を外部のDOM要素に渡しません。</p>
<h3 id="Composedイベント"><a class="anchor" href="#Composedイベント">#</a>Composedイベント</h3>
<p>デフォルトでshadow root内でdispatchされた上記で作成したイベントはshadow rootの外には伝播しません。
イベントがshadow domの外にも伝播するには<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/composed"><code>composed</code>プロパティ</a>を<code>true</code>にします。
通常、DOMツリーのすべてのNodeにイベントを伝播するために<code>composed</code>と一緒に<code>bubbles</code>も<code>true</code>にします。</p>
<pre><code class="language-js">_dispatchMyEvent() {
  let myEvent = new CustomEvent('my-event', {
    detail: { message: 'my-event happened.' },
    bubbles: true,
    composed: true });
  this.dispatchEvent(myEvent);
}
</code></pre>
<p>イベントの<code>composed</code>と<code>bubbles</code>が有効である場合、
イベントは(shadow rootの外側にある要素を含む)イベントをdispatchした要素のすべての祖先要素に伝播します。
イベントの<code>composed</code>が有効で<code>bubbles</code>が無効である場合、
イベントはイベントをdispatchした要素からDOMツリー上のshadow rootを含む要素まで伝播します。</p>
<p>すべてのマウスイベント、タッチイベント、キーボードイベントを含むほとんどの標準のユーザーインターフェースイベントでは<code>bubbles</code>と<code>composed</code>が両方有効です。
詳しくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/composed">こちら</a>を見てください。</p>
<h3 id="Eventのtargetプロパティ"><a class="anchor" href="#Eventのtargetプロパティ">#</a>Eventのtargetプロパティ</h3>
<p>shadow rootもしくはその祖先要素のイベントリスナで、
shadow root内でdispatchされた<a class="Link" href="#Composedイベント">Composedイベント</a>のtargetプロパティはDOMツリー上のshadow rootを含む要素になっています。
Litコンポーネントはshadow root内にレンダリングされるので、
Litコンポーネント内からdispatchされたComposedイベントはLitコンポーネントでdispatchされたように見えます。
その<code>Event</code>の<code>target</code>プロパティはLitコンポーネントです。</p>
<pre><code class="language-html">&lt;my-element onClick="(e) =&gt; console.log(e.target)"&gt;&lt;/my-element&gt;
</code></pre>
<pre><code class="language-js">render() {
  return html`
    &lt;button id="mybutton" @click="${(e) =&gt; console.log(e.target)}"&gt;
      click me
    &lt;/button&gt;`;
}
</code></pre>
<p>イベントが発生した要素を割り出したい場合、<code>event.composedPath()</code> APIを使います。
このメソッドはshadow root内の要素を含むすべてのイベントが通過したNodeの配列を返します。
これはカプセル化されている前提の実装を閲覧するので、それらライブラリの場合はその実装の変更に気づかないかもしれません。
だから、shadow root内の実装に依存するような処理を実装する際は注意してください。
これの一般的なユースケースはクライアントサイドのルーティングでクリックされた要素がアンカータグかどうかを判別することです。</p>
<pre><code class="language-js">handleMyEvent(event) {
  console.log('Origin: ', event.composedPath()[0]);
}
</code></pre>
<p>詳しくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Event/composedPath">composedPath</a>を見てください。</p>
<h2 id="イベントディスパッチャーとイベントリスナ間でデータをやり取りする"><a class="anchor" href="#イベントディスパッチャーとイベントリスナ間でデータをやり取りする">#</a>イベントディスパッチャーとイベントリスナ間でデータをやり取りする</h2>
<p>イベントはイベントの発信元からイベントリスナに変化を通知するために使われます。
そして、イベントリスナから発信元へそのイベントの返信することにも使うことができます。</p>
<p>これをする1つの方法はEventインスタンスに発信元のコンポーネントを操作するためのAPIを用意することです。
例えば、イベントリスナでCustomEventの<code>detail</code>プロパティにイベントの発信元のコンポーネントのプロパティをセットして、それを使ってコンポーネントの動作を変更します。</p>
<p>イベントの発信元とイベントリスナがやりとりをするもう1つ方法は<code>preventDefault()</code>を使う方法です。
<code>preventDefault()</code>はイベントが標準のアクションを実行しないことを示すために使われます。
イベントリスナが<code>preventDefault()</code>を実行するとイベントインスタンスの<code>defaultPrevented</code>プロパティの値を<code>true</code>にします。
このフラグはイベントリスナがイベントの発信元の動作を変更することに使うことができます。</p>
<p>この2つのテクニックは下記の例で使われています。</p>
<pre><code class="language-ts">import {LitElement, html} from 'lit';
import {customElement, property} from 'lit/decorators.js';

@customElement('my-listener')
class MyListener extends LitElement {
  @property() canCheck = false;
  protected render() {
    return html`
      &lt;p @checked=${this._checkedHandler}&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/p&gt;
      &lt;hr&gt;
      &lt;p&gt;${this.canCheck ? 'Allowing' : 'Preventing'} check&lt;/p&gt;
      &lt;p&gt;&lt;button @click=${this._clickHandler}&gt;Toggle&lt;/button&gt;&lt;/p&gt;`;
  }
  private _checkedHandler(e: CustomEvent) {
    if (!this.canCheck) {
      e.preventDefault();
      e.detail.message = '✅ Prevented!!';
    }
  }
  private _clickHandler() {
    this.canCheck = !this.canCheck;
  }
}


@customElement('my-dispatcher')
class MyDispatcher extends LitElement {
  @property() label = 'Check me!';
  defaultMessage = '🙂';
  @property() message = this.defaultMessage;
  private _resetMessage?: ReturnType&lt;typeof setTimeout&gt;;
  protected render() {
    return html`
      &lt;label&gt;&lt;input type="checkbox" @click=${this._tryChange}&gt;${this.label}&lt;/label&gt;
      &lt;div&gt;${this.message}&lt;/div&gt;
    `;
  }
  private _tryChange(e: Event) {
    const detail = {message: this.message};
    const event = new CustomEvent('checked', {detail, bubbles: true, composed: true, cancelable: true});
    this.dispatchEvent(event);
    if (event.defaultPrevented) {
      e.preventDefault();
    }
    this.message = detail.message;
  }
  protected updated() {
    clearTimeout(this._resetMessage);
    this._resetMessage =
      setTimeout(() =&gt; this.message = this.defaultMessage, 1000);
  }
}

// &lt;my-listener&gt;
//   &lt;my-dispatcher&gt;&lt;/my-dispatcher&gt;
// &lt;/my-listener&gt;
</code></pre>
<hr>
<h2 id="License"><a class="anchor" href="#License">#</a>License</h2>
<h3 id="Japanese_part"><a class="anchor" href="#Japanese_part">#</a>Japanese part</h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by-nc/4.0/legalcode">Creative Commons Attribution-NonCommercial 4.0 International Public License</a></p>
<p>Copyright (c) 2022 38elements</p>
<h3 id="Other"><a class="anchor" href="#Other">#</a>Other</h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by/3.0/deed.en">Creative Commons Attribution 3.0 Unported</a></p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>BSD 3-Clause License</p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ol>
<li><p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p>
</li>
<li><p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p>
</li>
<li><p>Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.</p>
</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </main>
    <div class="right-side"><nav class="header-list"><p class="h1"><a href="#イベント">イベント</a></p>
<p class="h2"><a href="#イベントリスニング">イベントリスニング</a></p>
<p class="h3"><a href="#テンプレートでイベントリスナを加える">テンプレートでイベントリスナを加える</a></p>
<p class="h4"><a href="#イベントリスナのオプションを設定する">イベントリスナのオプションを設定する</a></p>
<p class="h3"><a href="#コンポーネントもしくはshadow_rootにイベントリスナを追加する">コンポーネントもしくはshadow rootにイベントリスナを追加する</a></p>
<p class="h3"><a href="#他の要素にイベントリスナを追加する">他の要素にイベントリスナを追加する</a></p>
<p class="h3"><a href="#パフォーマンスの向上">パフォーマンスの向上</a></p>
<p class="h4"><a href="#Event_delegation">Event delegation</a></p>
<p class="h4"><a href="#非同期でイベントリスナを追加する">非同期でイベントリスナを追加する</a></p>
<p class="h3"><a href="#イベントリスナのthis">イベントリスナのthis</a></p>
<p class="h3"><a href="#ループするテンプレートでイベントを取り扱う">ループするテンプレートでイベントを取り扱う</a></p>
<p class="h3"><a href="#イベントリスナを削除する">イベントリスナを削除する</a></p>
<p class="h2"><a href="#イベントをdispatchする">イベントをdispatchする</a></p>
<p class="h3"><a href="#どんなときイベントをdispatchするべきか">どんなときイベントをdispatchするべきか</a></p>
<p class="h3"><a href="#要素の更新の後にイベントをdispatchする">要素の更新の後にイベントをdispatchする</a></p>
<p class="h3"><a href="#EventとCustomEventを扱う">EventとCustomEventを扱う</a></p>
<p class="h4"><a href="#CustomEventの使い方">CustomEventの使い方</a></p>
<p class="h4"><a href="#Eventの使い方">Eventの使い方</a></p>
<p class="h2"><a href="#Shadow_DOMでイベントを扱う">Shadow DOMでイベントを扱う</a></p>
<p class="h3"><a href="#Composedイベント">Composedイベント</a></p>
<p class="h3"><a href="#Eventのtargetプロパティ">Eventのtargetプロパティ</a></p>
<p class="h2"><a href="#イベントディスパッチャーとイベントリスナ間でデータをやり取りする">イベントディスパッチャーとイベントリスナ間でデータをやり取りする</a></p>
<p class="h2"><a href="#License">License</a></p>
<p class="h3"><a href="#Japanese_part">Japanese part</a></p>
<p class="h3"><a href="#Other">Other</a></p></nav></div>
    <footer class="footer markdown-body">
      <a href="/lit">Top</a>
    </footer>
  </body>
</html>