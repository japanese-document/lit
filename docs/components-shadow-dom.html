<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="twitter:card" content="summary" />
    <meta property="og:url" content="https://japanese-document.github.io/lit/components-shadow-dom.html" />
    <meta property="og:title" content="Shadow DOM" />
    <meta property="og:description" content="LitコンポーネントはDOMをカプセル化するためにShadow DOMを使います。Shadow DOMを使うとコンポーネントにdocumentから別箇でカプセル化されたDOMツリーを追加することができます。DOMのカプセル化はページ内で動作する(Web componentsやLitコンポーネントを含む)他のコードとの相互運用性を実現するための鍵です。Shadow DOMには下記の利点があります。DOMの公開範囲を限定します。document.querySelectorのようなDOM APIはコンポーネントのShadow DOMを見つけません。これはグローパルスクリプトが意図せずコンポーネントを" />
    <meta property="og:image" content="https://avatars2.githubusercontent.com/u/42838312?s=400" />
    <meta name="theme-color" content="#f1f7fe" />
    <meta name="description" content="LitコンポーネントはDOMをカプセル化するためにShadow DOMを使います。Shadow DOMを使うとコンポーネントにdocumentから別箇でカプセル化されたDOMツリーを追加することができます。DOMのカプセル化はページ内で動作する(Web componentsやLitコンポーネントを含む)他のコードとの相互運用性を実現するための鍵です。Shadow DOMには下記の利点があります。DOMの公開範囲を限定します。document.querySelectorのようなDOM APIはコンポーネントのShadow DOMを見つけません。これはグローパルスクリプトが意図せずコンポーネントを" />
    <title>Shadow DOM</title>
    <link rel="stylesheet" href="/lit/app.css?v=001" type="text/css"  media="all" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L9VVC74WWF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-L9VVC74WWF');
    </script>
  </head>
  <body class="container">
    <div class="left-side">
    <div class="index-menu">
      <details open="">
        <summary>コンポーネント</summary>
        <p><a href="https://japanese-document.github.io/lit/components-defining.html">定義</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-rendering.html">レンダリング</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-properties.html">リアクティブプロパティ</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-styles.html">スタイル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-lifecycle.html">ライフサイクル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-shadow-dom.html">Shadow DOM</a></p>
      </details>
      <details open="">
        <summary>テンプレート</summary>
        <p><a href="https://japanese-document.github.io/lit/templates-expressions.html">Expressions</a></p>
      </details>
      <details open="">
        <summary>API</summary>
        <p><a href="https://japanese-document.github.io/lit/api-LitElement.html">LitElement</a></p>
        <p><a href="https://japanese-document.github.io/lit/api-templates.html">テンプレート</a></p>
      </details>
    </div></div>
    <main class="main markdown-body">
      <h1 id="Shadow_DOM"><a href="#Shadow_DOM">Shadow DOM</a></h1>
<p>LitコンポーネントはDOMをカプセル化するために<a class="Link" href="https://developers.google.com/web/fundamentals/web-components/shadowdom">Shadow DOM</a>を使います。
Shadow DOMを使うとコンポーネントにdocumentから別箇でカプセル化されたDOMツリーを追加することができます。
DOMのカプセル化はページ内で動作する(Web componentsやLitコンポーネントを含む)他のコードとの相互運用性を実現するための鍵です。</p>
<p>Shadow DOMには下記の利点があります。</p>
<ul>
<li>DOMの公開範囲を限定します。<code>document.querySelector</code>のようなDOM APIはコンポーネントのShadow DOMを見つけません。これはグローパルスクリプトが意図せずコンポーネントを破壊する可能性を低くします。</li>
<li>スタイルの適用範囲を限定します。Shadow DOMのカプセル化されたスタイルはDOMツリーの属する他のDOMに影響を与えません。</li>
<li>組み合わせることができます。コンポーネントのshadow rootはコンポーネントのDOMを保有しますが、そのコンポーネントの子コンポーネントからは分離されています。親コンポーネントと子コンポーネント間で相互に相手のDOMにアクセスすることはできません。</li>
</ul>
<p>Shadow DOMに関する詳しい情報は<a class="Link" href="https://developers.google.com/web/fundamentals/web-components/shadowdom">Shadow DOM v1: Self-Contained Web Components</a>と<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM">Using shadow DOM</a>を見てください。</p>
<h2 id="Shadow_DOM内のNodeにアクセスする"><a href="#Shadow_DOM内のNodeにアクセスする">Shadow DOM内のNodeにアクセスする</a></h2>
<p>Litは<code>renderRoot</code>にコンポーネントをレンダリングします。shadow rootはデフォルトで<a class="Link" href="https://japanese-document.github.io/lit/api-LitElement.html#renderRoot()__Element_|_ShadowRoot">renderRoot</a>です。
コンポーネント内の要素を取得するために<code>this.renderRoot.querySelector()</code>のようなDOMクエリーAPIを使います。</p>
<p><code>renderRoot</code>はshadow rootもしくは1つの要素です。それらは<code>.querySelectorAll()</code>や<code>.children</code>のようなAPIを持ちます。</p>
<p>下記の例では、(<code>firstUpdated</code>で)コンポーネントの最初のレンダリングの後にコンポーネント内のDOMを取得しています。
また、ゲッタでコンポーネント内のDOMを取得しています。</p>
<pre><code class="language-js">firstUpdated() {
  this.staticNode = this.renderRoot.querySelector('#static-node');
}

get _closeButton() {
  return this.renderRoot.querySelector('#close-button');
}
</code></pre>
<p>LitElementは上記のゲッタの処理を省略して書くためのデコレータのセットを用意しています。</p>
<h3 id="_query、_queryAll、_queryAsyncデコレータ"><a href="#_query、_queryAll、_queryAsyncデコレータ">@query、@queryAll、@queryAsyncデコレータ</a></h3>
<p>@query、@queryAll、@queryAsyncデコレータを使うとコンポーネント内にあるNodeに簡単にアクセスすることができます。</p>
<h4 id="_query"><a href="#_query">@query</a></h4>
<p>クラスプロパティを<code>renderRoot</code>からNodeを返すゲッタに変更します。
オプションである第2引数にtrueを渡すとDOMクエリは1回のみ実行され、その結果がキャッシュされます。
これは取得対象のNodeが代わらないケースではパフォーマンスが向上します。</p>
<pre><code class="language-js">import {LitElement, html} from 'lit';
import {query} from 'lit/decorators/query.js';

class MyElement extends LitElement {
  @query('#first')
  _first;

  render() {
    return html`
      &lt;div id="first"&gt;&lt;/div&gt;
      &lt;div id="second"&gt;&lt;/div&gt;
    `;
  }
}
</code></pre>
<p>上記のデコレータを使ったコードは下記と等価です。</p>
<pre><code class="language-js">get _first() {
  return this.renderRoot?.querySelector('#first') ?? null;
}
</code></pre>
<h4 id="_queryAll"><a href="#_queryAll">@queryAll</a></h4>
<p><code>@query</code>と似ていますがマッチするNodeを1つだけ返すのではなくすべて返します。
これは<code>querySelectorAll</code>を実行することと等価です。</p>
<pre><code class="language-js">import {LitElement, html} from 'lit';
import {queryAll} from 'lit/decorators/queryAll.js';

class MyElement extends LitElement {
  @queryAll('div')
  _divs;

  render() {
    return html`
      &lt;div id="first"&gt;&lt;/div&gt;
      &lt;div id="second"&gt;&lt;/div&gt;
    `;
  }
}
</code></pre>
<p>上記の<code>_divs</code>はテンプレート内の<code>&lt;div&gt;</code>要素を2つとも返します。
TypeScriptでの<code>@queryAll</code>プロパティの型は<code>NodeListOf&lt;HTMLElement&gt;</code>です。
取得するNodeが明確である場合、より詳細な型を指定することができます。</p>
<pre><code class="language-js">@queryAll('button')
_buttons!: NodeListOf&lt;HTMLButtonElement&gt;
</code></pre>
<p><code>buttons</code>の後の<code>!</code>はTypeScriptの<a class="Link" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-0.html#non-null-assertion-operator">non-null assertion operator</a>です。
これは<code>buttons</code>には常に<code>null</code>と<code>undefined</code>が入らないことを示します。</p>
<h4 id="_queryAsync"><a href="#_queryAsync">@queryAsync</a></h4>
<p><code>@query</code>と似ています。<code>@queryAsync</code>はNodeを返すのではなく、保留中のレンダリングが完了した後にNodeを解決するPromiseを返します。
<code>updateComplete</code> Promiseをawaitする代わりにこれを使うことができます。
これは<code>@queryAsync</code>によって返されるNodeが他のプロパティの変更に影響を受ける場合役立ちます。</p>
<h2 id="slot要素を使って子要素をレンダリングする"><a href="#slot要素を使って子要素をレンダリングする">slot要素を使って子要素をレンダリングする</a></h2>
<p>下記のようにコンポーネントに子要素を配置することができます。</p>
<pre><code class="language-html">&lt;my-element&gt;
  &lt;p&gt;A child&lt;/p&gt;
&lt;/my-element&gt;
</code></pre>
<p>デフォルトでは要素がshadow treeを持つ場合、その子要素はレンダリングされません。</p>
<p>子要素をレンダリングするにはテンプレートに<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot"><code>&lt;slot&gt;</code>要素</a>を1つ以上配置する必要があります。
<code>&lt;slot&gt;</code>要素を使って子要素を配置する位置を指定します。</p>
<h3 id="slot要素を使う"><a href="#slot要素を使う">slot要素を使う</a></h3>
<p>子要素をレンダリングするには、要素のテンプレートに<code>&lt;slot&gt;</code>を配置します。
子要素は<code>&lt;slot&gt;</code>要素の子要素の様にレンダリングされます。</p>
<h3 id="名前付きslotを使う"><a href="#名前付きslotを使う">名前付きslotを使う</a></h3>
<p>子要素を指定した<code>slot</code>要素に割り当てるには、子要素の<code>slot</code>属性をslot要素の<code>name</code>属性にマッチさせます。</p>
<ul>
<li><p><strong>名前付きslotは子要素の<code>slot</code>属性とマッチした場合のみ適用されます。</strong></p>
<p>例: <code>&lt;slot name="one"&gt;&lt;/slot&gt;</code>は属性に<code>slot="one"</code>がある子要素のみ適用されます。</p>
</li>
<li><p><strong>slot属性を持つ子要素はその値とマッチするname属性を持つslot要素にレンダリングされます。</strong></p>
<p>例: <code>&lt;p slot="one"&gt;...&lt;/p&gt;</code>は<code>&lt;slot name="one"&gt;&lt;/slot&gt;</code>にのみ置き換えられます。</p>
</li>
</ul>
<pre><code class="language-html">&lt;my-element&gt;
  &lt;p slot="two"&gt;Include me in slot "two".&lt;/p&gt;
&lt;/my-element&gt;

&lt;hr&gt;

&lt;my-element&gt;
  &lt;p slot="one"&gt;Include me in slot "one".&lt;/p&gt;
  &lt;p slot="nope"&gt;This one will not render at all.&lt;/p&gt;
  &lt;p&gt;No default slot, so this one won't render either.&lt;/p&gt;
&lt;/my-element&gt;
</code></pre>
<pre><code class="language-ts">import {LitElement, html} from 'lit';
import {customElement} from 'lit/decorators.js';

@customElement('my-element')
export class MyElement extends LitElement {
  protected render() {
    return html`
      &lt;p&gt;
        &lt;slot name="one"&gt;&lt;/slot&gt;
        &lt;slot name="two"&gt;&lt;/slot&gt;
      &lt;/p&gt;
    `;
  }
}
</code></pre>
<h3 id="デフォルトでslotに適用されるコンテンツを指定する"><a href="#デフォルトでslotに適用されるコンテンツを指定する">デフォルトでslotに適用されるコンテンツを指定する</a></h3>
<p>slot要素に割り当てられるデフォルトのコンテンツを指定することができます。
slot要素に対応するコンテンツが存在しない場合、デフォルトのコンテンツは表示されます。</p>
<pre><code class="language-html">&lt;slot&gt;I am fallback content&lt;/slot&gt;
</code></pre>
<p><strong>デフォルトのコンテンツをレンダリングする</strong>
子Nodeがslotに適用された場合、デフォルトのコンテンツはレンダリングされません。
name属性のないslot要素は任意の子Nodeを適用します。
<code>&lt;example-element&gt; &lt;/example-element&gt;</code>の様に子Nodeがスペースだけの場合でもデフォルトのコンテンツはレンダリングされません。
custom elementの子要素にLitエクスプレッションを使う場合、
意図した通りにデフォルトのコンテンツがレンダリングされるようにレンダリングしない値を使ってください。
詳しくは<a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#子コンテンツの削除">レンダリングしない値</a>を見てください。</p>
<h2 id="slotに適用された子要素にアクセスする"><a href="#slotに適用された子要素にアクセスする">slotに適用された子要素にアクセスする</a></h2>
<p>shadow root内のslotに割り当てられた子要素にアクセスするには、
<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/slotchange_event">slotchange</a>イベントでWeb標準の<code>slot.assignedNodes</code>メソッドもしくは<code>slot.assignedElements</code>メソッドを使います。</p>
<p>下記のように、特定のslotに割り当てられた要素を返すゲッタを作成することができます。</p>
<pre><code class="language-js">get _slottedChildren() {
  const slot = this.shadowRoot.querySelector('slot');
  return slot.assignedElements({flatten: true});
}
</code></pre>
<p><code>slotchange</code>イベントを使うとslotに割り当てられたNodeが変更された時に処理を実行することができます。
下記の例では、すべてのslotに割り当てられた要素のテキストコンテンツを取得しています。</p>
<pre><code class="language-js">handleSlotchange(e) {
  const childNodes = e.target.assignedNodes({flatten: true});
  this.allText = childNodes.map((node) =&gt; {
    return node.textContent ? node.textContent : ''
  }).join('');
}

render() {
  return html`&lt;slot @slotchange=${this.handleSlotchange}&gt;&lt;/slot&gt;`;
}
</code></pre>
<p>詳しくは<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement">HTMLSlotElement</a>を見てください。</p>
<h3 id="_queryAssignedElementsデコレータと_queryAssignedNodesデコレータ"><a href="#_queryAssignedElementsデコレータと_queryAssignedNodesデコレータ">@queryAssignedElementsデコレータと@queryAssignedNodesデコレータ</a></h3>
<p><code>@queryAssignedElements</code>はクラスのプロパティを指定したslotの<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/assignedElements"><code>slot.assignedElements</code></a>を返すgetterに変換します。
<code>@queryAssignedNodes</code>はクラスのプロパティを指定したslotの<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLSlotElement/assignedNodes"><code>slot.assignedNodes</code></a>を返すgetterに変換します。
これらのクエリを使ってslotに割り当てられた要素もしくはNodeを取得します。</p>
<p>これら2つのデコレータにオプションで下記のプロパティを持つobjectを渡すことができます。</p>
<table>
<thead>
<tr>
<th>プロパティ</th>
<th>説明</th>
</tr>
</thead>
<tbody><tr>
<td><code>flatten</code></td>
<td>Boolean specifying whether to flatten the assigned nodes by replacing any child <code>&lt;slot&gt;</code> elements with their assigned nodes.</td>
</tr>
<tr>
<td><code>slot</code></td>
<td>Slot name specifying the slot to query. Leave undefined to select the default slot.</td>
</tr>
<tr>
<td><code>selector</code> (<code>queryAssignedElements</code>のみ)</td>
<td>If specified, only return assigned elements that match this CSS selector.</td>
</tr>
</tbody></table>
<p>Deciding which decorator to use depends on whether you want to query for text nodes assigned to the slot, or only element nodes. This decision is specific to your use case.</p>
<pre><code class="language-ts">@queryAssignedElements({slot: 'list', selector: '.item'})
_listItems!: Array&lt;HTMLElement&gt;;

@queryAssignedNodes({slot: 'header', flatten: true})
_headerNodes!: Array&lt;Node&gt;;
</code></pre>
<p>The examples above are equivalent to the following code:</p>
<pre><code class="language-js">get _listItems() {
  const slot = this.shadowRoot.querySelector('slot[name=list]');
  return slot.assignedElements().filter((node) =&gt; node.matches('.item'));
}

get _headerNodes() {
  const slot = this.shadowRoot.querySelector('slot[name=header]');
  return slot.assignedNodes({flatten: true});
}
</code></pre>
<h2 id="render_rootを変更する"><a href="#render_rootを変更する">render rootを変更する</a></h2>
<p>Each Lit component has a <strong>render root</strong>—a DOM node that serves as a container for its internal DOM.</p>
<p>By default, LitElement creates an open <code>shadowRoot</code> and renders inside it, producing the following DOM structure:</p>
<pre><code class="language-html">&lt;my-element&gt;
  #shadow-root
    &lt;p&gt;child 1&lt;/p&gt;
    &lt;p&gt;child 2&lt;/p&gt;
</code></pre>
<p>There are two ways to customize the render root used by LitElement:</p>
<ul>
<li>Setting <code>shadowRootOptions</code>.</li>
<li>Implementing the <code>createRenderRoot</code> method.</li>
</ul>
<h3 id="shadowRootOptionsを変更する"><a href="#shadowRootOptionsを変更する"><code>shadowRootOptions</code>を変更する</a></h3>
<p>The simplest way to customize the render root is to set the <code>shadowRootOptions</code> static property. The default implementation of <code>createRenderRoot</code> passes <code>shadowRootOptions</code> as the options argument to <code>attachShadow</code> when creating the component's shadow root. It can be set to customize any options allowed in the <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow#parameters">ShadowRootInit</a> dictionary, for example <code>mode</code> and <code>delegatesFocus</code>.</p>
<pre><code class="language-js">class DelegatesFocus extends LitElement {
  static shadowRootOptions = {...LitElement.shadowRootOptions, delegatesFocus: true};
}
</code></pre>
<p>See <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/Element/attachShadow">Element.attachShadow()</a> on MDN for more information.</p>
<h3 id="createRenderRootを実装する"><a href="#createRenderRootを実装する"><code>createRenderRoot</code>を実装する</a></h3>
<p>The default implementation of <code>createRenderRoot</code> creates an open shadow root and adds to it any styles set in the <code>static styles</code> class field. For more information on styling see <a class="Link" href="/docs/components/styles/">Styles</a>.</p>
<p>To customize a component's render root, implement <code>createRenderRoot</code> and return the node you want the template to render into.</p>
<p>For example, to render the template into the main DOM tree as your element's children, implement <code>createRenderRoot</code> and return <code>this</code>.</p>
<div class="alert alert-info">

<p><strong>Rendering into children.</strong> Rendering into children and not shadow DOM is generally not recommended. Your element will not have access to DOM or style scoping, and it will not be able to compose elements into its internal DOM.</p>
</div>

<p>{% playground-ide "docs/components/shadowdom/renderroot/" %}</p>
<hr>
<h2 id="License"><a href="#License">License</a></h2>
<h3 id="Japanese_part"><a href="#Japanese_part">Japanese part</a></h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by-nc/4.0/legalcode">Creative Commons Attribution-NonCommercial 4.0 International Public License</a></p>
<p>Copyright (c) 2022 38elements</p>
<h3 id="Other"><a href="#Other">Other</a></h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by/3.0/deed.en">Creative Commons Attribution 3.0 Unported</a></p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>BSD 3-Clause License</p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ol>
<li><p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p>
</li>
<li><p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p>
</li>
<li><p>Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.</p>
</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </main>
    <div class="right-side"><div class="header-list"><p class="h1"><a href="#Shadow_DOM">Shadow DOM</a></p>
<p class="h2"><a href="#Shadow_DOM内のNodeにアクセスする">Shadow DOM内のNodeにアクセスする</a></p>
<p class="h3"><a href="#_query、_queryAll、_queryAsyncデコレータ">@query、@queryAll、@queryAsyncデコレータ</a></p>
<p class="h4"><a href="#_query">@query</a></p>
<p class="h4"><a href="#_queryAll">@queryAll</a></p>
<p class="h4"><a href="#_queryAsync">@queryAsync</a></p>
<p class="h2"><a href="#slot要素を使って子要素をレンダリングする">slot要素を使って子要素をレンダリングする</a></p>
<p class="h3"><a href="#slot要素を使う">slot要素を使う</a></p>
<p class="h3"><a href="#名前付きslotを使う">名前付きslotを使う</a></p>
<p class="h3"><a href="#デフォルトでslotに適用されるコンテンツを指定する">デフォルトでslotに適用されるコンテンツを指定する</a></p>
<p class="h2"><a href="#slotに適用された子要素にアクセスする">slotに適用された子要素にアクセスする</a></p>
<p class="h3"><a href="#_queryAssignedElementsデコレータと_queryAssignedNodesデコレータ">@queryAssignedElementsデコレータと@queryAssignedNodesデコレータ</a></p>
<p class="h2"><a href="#render_rootを変更する">render rootを変更する</a></p>
<p class="h3"><a href="#shadowRootOptionsを変更する">shadowRootOptionsを変更する</a></p>
<p class="h3"><a href="#createRenderRootを実装する">createRenderRootを実装する</a></p>
<p class="h2"><a href="#License">License</a></p>
<p class="h3"><a href="#Japanese_part">Japanese part</a></p>
<p class="h3"><a href="#Other">Other</a></p></div></div>
    <footer class="footer markdown-body">
      <a href="/lit">Top</a>
    </footer>
  </body>
</html>