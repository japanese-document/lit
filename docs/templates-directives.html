<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="twitter:card" content="summary" />
    <meta property="og:url" content="https://japanese-document.github.io/lit/templates-directives.html" />
    <meta property="og:title" content="ビルトインディレクティブ" />
    <meta property="og:description" content="ディレクティブを使うとエクスプレッションのレンダリング方法を変更することによってLitを拡張することができます。Litは下記のような多様な用途に対応したビルドインディレクティブを用意しています。  ディレクティブサマリー    スタイル        classMap      渡されたobjectに応じて要素にclass属性を割り当てます。          styleMap      渡されたobjectに応じて要素にstyle属性を割り当てます。      繰り返しと条件        when    条件に応じて渡された2つのテンプレートの内1つをレンダリングします。        c" />
    <meta property="og:image" content="https://avatars2.githubusercontent.com/u/42838312?s=400" />
    <meta name="theme-color" content="#f1f7fe" />
    <meta name="description" content="ディレクティブを使うとエクスプレッションのレンダリング方法を変更することによってLitを拡張することができます。Litは下記のような多様な用途に対応したビルドインディレクティブを用意しています。  ディレクティブサマリー    スタイル        classMap      渡されたobjectに応じて要素にclass属性を割り当てます。          styleMap      渡されたobjectに応じて要素にstyle属性を割り当てます。      繰り返しと条件        when    条件に応じて渡された2つのテンプレートの内1つをレンダリングします。        c" />
    <meta name="Hatena::Bookmark" content="nocomment" />
    <title>ビルトインディレクティブ</title>
    <link rel="stylesheet" href="/lit/app.css?v=001" type="text/css"  media="all" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L9VVC74WWF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-L9VVC74WWF');
    </script>
  </head>
  <body class="container">
    <div class="left-side">
    <div class="index-menu">
      <details open="">
        <summary>コンポーネント</summary>
        <p><a href="https://japanese-document.github.io/lit/components-defining.html">定義</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-rendering.html">レンダリング</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-properties.html">リアクティブプロパティ</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-styles.html">スタイル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-lifecycle.html">ライフサイクル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-shadow-dom.html">Shadow DOM</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-events.html">イベント</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-decorators.html">デコレータ</a></p>
      </details>
      <details open="">
        <summary>テンプレート</summary>
        <p><a href="https://japanese-document.github.io/lit/templates-expressions.html">Expressions</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-directives.html">ビルトインディレクティブ</a></p>
      </details>
      <details open="">
        <summary>API</summary>
        <p><a href="https://japanese-document.github.io/lit/api-LitElement.html">LitElement</a></p>
        <p><a href="https://japanese-document.github.io/lit/api-templates.html">テンプレート</a></p>
      </details>
    </div></div>
    <main class="main markdown-body">
      <h1 id="ビルトインディレクティブ"><a href="#ビルトインディレクティブ">ビルトインディレクティブ</a></h1>
<p>ディレクティブを使うとエクスプレッションのレンダリング方法を変更することによってLitを拡張することができます。
Litは下記のような多様な用途に対応したビルドインディレクティブを用意しています。</p>
<table class="directory">
  <tbody><tr><th>ディレクティブ</th><th>サマリー</th></tr>
  <tr class="subheading"><td colspan="2">

<p>  スタイル</p>
  </td></tr>
  <tr>
  <td>

<p>  <a class="Link" href="#classMap"><code>classMap</code></a></p>
  </td>
  <td>
  渡されたobjectに応じて要素にclass属性を割り当てます。
  </td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#styleMap"><code>styleMap</code></a></p>
  </td>
  <td>
  渡されたobjectに応じて要素にstyle属性を割り当てます。
  </td></tr>

  <tr class="subheading"><td colspan="2">

<p>  繰り返しと条件</p>
  </td></tr>

  <tr>
  <td>

<p>  <a class="Link" href="#when"><code>when</code></a></p>
  </td>
  <td>条件に応じて渡された2つのテンプレートの内1つをレンダリングします。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#choose"><code>choose</code></a></p>
  </td>
  <td>オブジェクトのキーの値に応じて指定した多数のテンプレートの内1つをレンダリングします。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#map"><code>map</code></a></p>
  </td>
  <td>iterableの各値を指定した関数で変換します。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#repeat"><code>repeat</code></a></p>
  </td>
  <td>iterableの各値をDOMにレンダリングします。オプションでそれらにkeyを付与する処理を追加することができます。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#join"><code>join</code></a></p>
  </td>
  <td>iterableの各値を指定した値で連結します。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#range"><code>range</code></a></p>
  </td>
  <td>連続した数値を値に持つiterableを生成します。これは繰り返しの回数を指定する際に便利です。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#ifDefined"><code>ifDefined</code></a></p>
  </td>
  <td>値が定義されている場合は属性をセットします。undefinedの場合は属性を削除します。</td>
  </tr>

  <tr class="subheading"><td colspan="2">

<p>  キャッシュと変更の検出</p>
  </td></tr>

  <tr>
  <td>

<p>  <a class="Link" href="#cache"><code>cache</code></a></p>
  </td>
  <td>テンプレートを変更した時、DOMを破棄するのではなくレンダリング済みのDOMをキャッシュします。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#keyed"><code>keyed</code></a></p>
  </td>
  <td>レンダリング可能な値とユニークなキーを関連付けます。そして、キーが変化すると強制的に関連付けられた値が強制的に再レンダリングされます。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#guard"><code>guard</code></a></p>
  </td>
  <td>指定した変更を検知するための値の内1つが変更された場合のみテンプレートを再評価します。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#live"><code>live</code></a></p>
  </td>
  <td>最後にレンダリングされた時の値が現行のDOMの属性もしくはプロパティと異なっていた場合、それに値をセットします。</td>
  </tr>

  <tr class="subheading"><td colspan="2">

<p>  レンダリングされたDOMの参照</p>
  </td></tr>

  <tr>
  <td>

<p>  <a class="Link" href="#ref"><code>ref</code></a></p>
  </td>
  <td>テンプレートでレンダリングされた要素の参照を取得します。</td>
  </tr>

  <tr class="subheading"><td colspan="2">

<p>  特殊な値のレンダリング</p>
  </td></tr>

  <tr>
  <td>

<p>  <a class="Link" href="#templateContent"><code>templateContent</code></a></p>
  </td>
  <td>

<p>  <code>&lt;template&gt;</code>要素のコンテンツをレンダリングします。</p>
  </td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#unsafeHTML"><code>unsafeHTML</code></a></p>
  </td>
  <td>文字列をテキストではなくHTMLとしてレンダリングします。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#unsafeSVG"><code>unsafeSVG</code></a></p>
  </td>
  <td>文字列をテキストではなくSVGとしてレンダリングします。</td>
  </tr>

  <tr class="subheading"><td colspan="2">

<p>  非同期レンダリング</p>
  </td></tr>

  <tr>
  <td>

<p>  <a class="Link" href="#until"><code>until</code></a></p>
  </td>
  <td>1つ以上のPromiseが解決するまでプレイスフォルダのコンテンツをレンダリングします。</td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#asyncAppend"><code>asyncAppend</code></a></p>
  </td>
  <td>

<p>  <code>AsyncIterable</code>の各値を解決される毎にDOMに追記していきます。</p>
  </td>
  </tr>

  <tr>
  <td>

<p>  <a class="Link" href="#asyncReplace"><code>asyncReplace</code></a></p>
  </td>
  <td>

<p>  <code>AsyncIterable</code>の各値を解決される毎にDOMを置き換えます。</p>
  </td>
  </tr>
</tbody></table>

<p>独自のディレクティブを作成することができます。
詳しくは<a class="Link" href="https://lit.dev/docs/templates/custom-directives/">カスタムディレクティブ</a>を見てください。</p>
<h2 id="スタイル"><a href="#スタイル">スタイル</a></h2>
<h3 id="classMap"><a href="#classMap">classMap</a></h3>
<p>渡されたobjectに応じて要素にclass属性のリストを割り当てます。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {classMap} from 'lit/directives/class-map.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">classMap(classInfo: {[name: string]: string | boolean | number})
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p><code>class</code>属性に対応する<a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html">エクスプレッション</a></p>
</td>
</tr>
</tbody>
</table>

<p><code>classMap</code>ディレクディブは渡されたオブジェクトに応じて<code>element.classList</code>を使って効率的にclass属性に値を追加および削除します。
オブジェクトの各キーはclass名です。その値がtrueと評価できる場合、要素のclass属性にそのclass名を加えます。
その後のレンダリングでは、1つ前のレンダリングでclass属性にセットされていたclass名のうち値がfalseと評価できるものやオブジェクトにキーが存在しないものはclass属性から削除されます。</p>
<pre><code class="language-ts">@customElement('my-element')
class MyElement extends LitElement {

  @property({type: Boolean})
  enabled = false;

  render() {
    const classes = { enabled: this.enabled, hidden: false };
    return html`&lt;div class=${classMap(classes)}&gt;Classy text&lt;/div&gt;`;
  }
}
</code></pre>
<p><code>classMap</code>は下記のようにclass属性の静的な値と組み合わせることができます。</p>
<pre><code class="language-ts">html`&lt;div class="my-widget ${classMap(dynamicClasses)}"&gt;Static and dynamic&lt;/div&gt;`;
</code></pre>
<p><code>classMap</code>を使用した例は<a class="Link" href="https://lit.dev/playground/#sample=examples/directive-class-map">こちら</a>です。</p>
<h3 id="styleMap"><a href="#styleMap">styleMap</a></h3>
<p>渡されたobjectに応じて要素にstyleプロパティのリストを割り当てます。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {styleMap} from 'lit/directives/style-map.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">styleMap(styleInfo: {[name: string]: string | undefined | null})
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p><code>style</code>属性に対応する<a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html">エクスプレッション</a></p>
</td>
</tr>
</tbody>
</table>

<p><code>styleMap</code>ディレクティブは渡されたオブジェクトに応じて<code>element.style</code> APIを使って効率的に要素のstyle属性にスタイルを追加したり削除したりします。
渡されたオブジェクトの各キーはスタイルのプロパティ名になります。その値はスタイルのプロパティの値になります。
その後のレンダリングでは、値がセットされていなかったり<code>null</code>の場合は1つ前のレンダリングでセットされていたスタイルプロパティは削除されます。</p>
<pre><code class="language-ts">@customElement('my-element')
class MyElement extends LitElement {

  @property({type: Boolean})
  enabled = false;

  render() {
    const styles = { backgroundColor: this.enabled ? 'blue' : 'gray', color: 'white' };
    return html`&lt;p style=${styleMap(styles)}&gt;Hello style!&lt;/p&gt;`;
  }
}
</code></pre>
<p>下記のようにCSSプロパティ名に<code>-</code>が含まれている場合、camel-caseにするか、プロパティ名を<code>'</code>内に置きます。
例えば、<code>font-family</code>は<code>fontFamily</code>もしくは<code>'font-family'</code>にすることができます。</p>
<pre><code class="language-js">{ fontFamily: 'roboto' }
{ 'font-family': 'roboto' }
</code></pre>
<p>CSSカスタムプロパティを参照する場合、下記のようにプロパティ名全体を<code>'</code>内に置きます。</p>
<pre><code class="language-js">{ '--custom-color': 'steelblue' }
</code></pre>
<p><code>styleMap</code>はstyle属性内の唯一のエクスプレッションでなければなりませんが、下記のように静的な値と組み合わせることができます。</p>
<pre><code class="language-js">html`&lt;p style="color: white; ${styleMap(moreStyles)}"&gt;More styles!&lt;/p&gt;`;
</code></pre>
<p>詳しくは<a class="Link" href="https://lit.dev/playground/#sample=examples/directive-style-map">playground</a>を見てください。</p>
<h2 id="繰り返しと条件"><a href="#繰り返しと条件">繰り返しと条件</a></h2>
<h3 id="when"><a href="#when">when</a></h3>
<p>条件に応じて渡された2つのテンプレートの内1つをレンダリングします。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {when} from 'lit/directives/when.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">when&lt;T, F&gt;(
  condition: boolean,
  trueCase: () =&gt; T,
  falseCase?: () =&gt; F
)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>どこでも</p>
</td>
</tr>
</tbody>
</table>

<p><code>condition</code>がtrueの場合、<code>trueCase()</code>を実行した結果を返します。そうでない場合、<code>falseCase</code>が渡されているなら<code>falseCase()</code>を実行した結果を返します。
これは三項演算子のラッパーです。これを使うとelseを使わないでインラインで書くことができるので少しだけキレイに書くことができます。</p>
<pre><code class="language-ts">class MyElement extends LitElement {
  render() {
    return html`
      ${when(this.user, () =&gt; html`User: ${this.user.username}`, () =&gt; html`Sign In...`)}
    `;
  }
}
</code></pre>
<h3 id="choose"><a href="#choose">choose</a></h3>
<p>渡された<code>value</code>にマッチする関数を実行してテンプレートを返します。
<code>case</code>にはキーとテンプレートを返す関数の配列を渡します。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {choose} from 'lit/directives/choose.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">choose&lt;T, V&gt;(
  value: T,
  cases: Array&lt;[T, () =&gt; V]&gt;,
  defaultCase?: () =&gt; V
)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>どこでも</p>
</td>
</tr>
</tbody>
</table>


<p><code>cases</code>の構造は<code>[caseValue, func]</code>です。
<code>value</code>は<code>caseValue</code>と<code>===</code>で比較されます。
最初にマッチしたものを採用します。
<code>caseValue</code>には任意の型の値を指定することができます。</p>
<pre><code class="language-ts">class MyElement extends LitElement {
  render() {
    return html`
      ${choose(this.section, [
        ['home', () =&gt; html`&lt;h1&gt;Home&lt;/h1&gt;`],
        ['about', () =&gt; html`&lt;h1&gt;About&lt;/h1&gt;`]
      ],
      () =&gt; html`&lt;h1&gt;Error&lt;/h1&gt;`)}
    `;
  }
}
</code></pre>
<h3 id="map"><a href="#map">map</a></h3>
<p><code>items</code>の各値に対して<code>f(value)</code>を実行した結果を格納しているiterableを返します。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {map} from 'lit/directives/map.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">map&lt;T&gt;(
  items: Iterable&lt;T&gt; | undefined,
  f: (value: T, index: number) =&gt; unknown
)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>どこでも</p>
</td>
</tr>
</tbody>
</table>

<p><code>map()</code>は<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of">for/of loop</a>の簡単なラッパです。
これはエクスプレッション内でのiterableに対する処理を少しだけ簡単にします。
<code>map()</code>で生成されたすべてのDOMは更新されます。(差分やDOMの移動は発生しません。)
それが必要な場合は<a class="Link" href="#repeat">repeat</a>を見てください。
<code>map()</code>は<code>repeat()</code>より低コストで高速です。だから、差分やDOMの安定性が必要ない場合は<code>map()</code>を使うことが好ましいです。</p>
<pre><code class="language-ts">class MyElement extends LitElement {
  render() {
    return html`
      &lt;ul&gt;
        ${map(items, (i) =&gt; html`&lt;li&gt;${i}&lt;/li&gt;`)}
      &lt;/ul&gt;
    `;
  }
}
</code></pre>
<h3 id="repeat"><a href="#repeat">repeat</a></h3>
<p>iterableの値をDOMにレンダリングします。その際にDOMの安定性を付与するためにキーをDOMに付与します。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {repeat} from 'lit/directives/repeat.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">repeat(items: Iterable&lt;T&gt;, keyfn: KeyFn&lt;T&gt;, template: ItemTemplate&lt;T&gt;)
repeat(items: Iterable&lt;T&gt;, template: ItemTemplate&lt;T&gt;)
type KeyFn&lt;T&gt; = (item: T, index: number) =&gt; unknown;
type ItemTemplate&lt;T&gt; = (item: T, index: number) =&gt; unknown;
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p><a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Child_expressions">Child expression</a></p>
</td>
</tr>
</tbody>
</table>

<p><code>repeat</code>はiterableからレンダリング対象の値(通常は<code>TemplateResults</code>の配列)を生成します。
そして、iterableが変更された時、それらを効率的に更新します。
<code>keyFn</code>が渡された場合、キーがDOMに付与されます。
キーとDOMの関係はDOMが移動する更新で維持されます。
これは不要な要素の挿入と削除を最小にすることができるので、一般的に<code>repeat</code>を使うことは最も効率的な方法です。</p>
<p><code>keyFn</code>が必要ない場合、<a class="Link" href="#map"><code>map()</code></a>を使うことを検討した方が良いかもしれません。</p>
<pre><code class="language-ts">@customElement('my-element')
class MyElement extends LitElement {

  @property()
  items: Array&lt;{id: number, name: string}&gt; = [];

  render() {
    return html`
      &lt;ul&gt;
        ${repeat(this.items, (item) =&gt; item.id, (item, index) =&gt; html`
          &lt;li&gt;${index}: ${item.name}&lt;/li&gt;`)}
      &lt;/ul&gt;
    `;
  }
}
</code></pre>
<p><code>keyFn</code>が渡されなかった場合、<code>repeat</code>は単純な<code>map</code>と似た動きをします。
その場合、DOMは違う値と関連付けられる可能性があります。</p>
<p>詳しくは<a class="Link" href="https://lit.dev/docs/templates/lists/#when-to-use-map-or-repeat">mapとrepeatの使い分け</a>を見てください。</p>
<h3 id="join"><a href="#join">join</a></h3>
<p><code>items</code>の各値の間に<code>joiner</code>の値を挿入したiterableを返します。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {join} from 'lit/directives/join.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">join&lt;I, J&gt;(
  items: Iterable&lt;I&gt; | undefined,
  joiner: J
): Iterable&lt;I | J&gt;;

join&lt;I, J&gt;(
  items: Iterable&lt;I&gt; | undefined,
  joiner: (index: number) =&gt; J
): Iterable&lt;I | J&gt;;
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>どこでも</p>
</td>
</tr>
</tbody>
</table>

<pre><code class="language-ts">
class MyElement extends LitElement {

  render() {
    return html`
      ${join(
        map(menuItems, (i) =&gt; html`&lt;a href=${i.href}&gt;${i.label}&lt;/a&gt;`),
        html`&lt;span class="separator"&gt;|&lt;/span&gt;`
      )}
    `;
  }
}
</code></pre>
<h3 id="range"><a href="#range">range</a></h3>
<p><code>start</code>から<code>end</code>まで<code>step</code>分だけ増加した一連の整数のiterableを返します。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {range} from 'lit/directives/range.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">range(end: number): Iterable&lt;number&gt;;

range(
  start: number,
  end: number,
  step?: number
): Iterable&lt;number&gt;;
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>Any</p>
</td>
</tr>
</tbody>
</table>

<pre><code class="language-ts">
class MyElement extends LitElement {

  render() {
    return html`
      ${map(range(8), (i) =&gt; html`${i + 1}`)}
    `;
  }
}
</code></pre>
<h3 id="ifDefined"><a href="#ifDefined">ifDefined</a></h3>
<p>渡された値が定義されているなら属性をセットします。未定義なら属性を削除します。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {ifDefined} from 'lit/directives/if-defined.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">ifDefined(value: unknown)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p><a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Attribute_expressions">Attribute expression</a></p>
</td>
</tr>
</tbody>
</table>

<p>このディレクティブは属性部分に配置された場合、値が定義されていると属性をセットします。値が未定義(<code>undefined</code>もしくは<code>null</code>)だと属性を削除します。
他の部分に配置された場合、何もしません。</p>
<p>1つの属性に1つ以上のエクスプレッションが存在する場合、
1つでも<code>ifDefined</code>に<code>undefined</code>/<code>null</code>渡されたものがある場合、その属性は削除されます。
これはurlの属性をセットする際に特に便利です。
urlに必要な部分が定義されていない場合、404を防ぐために属性をセットしません。</p>
<pre><code class="language-ts">@customElement('my-element')
class MyElement extends LitElement {

  @property()
  filename: string | undefined = undefined;

  @property()
  size: string | undefined = undefined;

  render() {
    // sizeもしくはfilenameが未定義の場合、src属性はレンダリングさません。
    return html`&lt;img src="/images/${ifDefined(this.size)}/${ifDefined(this.filename)}"&gt;`;
  }
}
</code></pre>
<h2 id="キャッシュと変更の検出"><a href="#キャッシュと変更の検出">キャッシュと変更の検出</a></h2>
<h3 id="cache"><a href="#cache">cache</a></h3>
<p>渡されたテンプレートが変更した時、レンダリングされたDOMを廃棄するのではなくキャッシュします。
大きなテンプレートを頻繁に切り替える場合、このディレクティブを使うことでパフォーマンスが改善されます。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {cache} from 'lit/directives/cache.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">cache(value: TemplateResult|unknown)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p><a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Child_expressions">Child expression</a></p>
</td>
</tr>
</tbody>
</table>

<p><code>cache</code>に渡された<code>TemplateResult</code>が変更されると、
渡されたテンプレートがレンダリングされたDOMはそれらが使われない時にキャッシュされます。
テンプレートが変更されると、このディレクティブは新しい値に切り替える前に現行のDOM Nodeをキャッシュします。
このディレクティブは過去にレンダリングされた値に戻す時、新しいDOM Nodeを生成するのではなくキャッシュから復元します。</p>
<pre><code class="language-ts">const detailView = (data) =&gt; html`&lt;div&gt;...&lt;/div&gt;`;
const summaryView = (data) =&gt; html`&lt;div&gt;...&lt;/div&gt;`;

@customElement('my-element')
class MyElement extends LitElement {

  @property()
  data = {showDetails: true, /*...*/ };

  render() {
    return html`${cache(this.data.showDetails
      ? detailView(this.data)
      : summaryView(this.data)
    )}`;
  }
}
</code></pre>
<p>Litのデフォルトの動作は、テンプレートを再レンダリングすると、変更された部分のみが更新されます。
必要なDOMのみが作成または削除されます。
しかし、レンダリングされるテンプレートが別のテンプレートに切り替わると、
Litは現行のDOM treeを削除して新しいDOMツリーをレンダリングします。</p>
<p><code>cache</code>ディレクティブは生成されたDOMをキャッシュします。
上記の例は<code>summaryView</code>および<code>detailView</code>の両方に対するDOMをキャッシュします。
When you switch from one view to another, Lit swaps in the cached version of the new view and updates it with the latest data.
This can improve rendering performance when these views are frequently switched.</p>
<h3 id="keyed"><a href="#keyed">keyed</a></h3>
<p>ユニークなキーとレンダリング可能な値を関連付けます。
キーが変更されると、
テンプレートの内容が同じでも、
次の値がレンダリングされる前に現行のDOMは削除されて破棄されます。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {keyed} from 'lit/directives/keyed.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">keyed(key: unknown, value: unknown)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>すべてのエクスプレッション</p>
</td>
</tr>
</tbody>
</table>

<p><code>keyed</code>はステートを持つ要素をレンダリングしていて重要なデータが変更されて要素のすべてのステートを確実にクリアする必要がある時に役立ちます。
これは基本的にLitのデフォルトのDOMを再利用する方針とは異なります。</p>
<p><code>keyed</code>は新しい要素にenterやexitのアニメーションを適用にするようなCSSアニメーションを制作する際にも役立ちます。</p>
<pre><code class="language-ts">@customElement('my-element')
class MyElement extends LitElement {

  @property()
  userId: string = '';

  render() {
    return html`
      &lt;div&gt;
        ${keyed(this.userId, html`&lt;user-card .userId=${this.userId}&gt;&lt;/user-card&gt;`)}
      &lt;/div&gt;`;
  }
}
</code></pre>
<h3 id="guard"><a href="#guard">guard</a></h3>
<p><code>dependencies</code>が1つでも変更された場合のみテンプレートが再評価されます。
これによってレンダリングの不要な作業を削減することでパフォーマンスが改善されます。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {guard} from 'lit/directives/guard.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">guard(dependencies: unknown[], valueFn: () =&gt; unknown)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>すべてのエクスプレッション</p>
</td>
</tr>
</tbody>
</table>

<p><code>valueFn</code>の戻り値をレンダリングします。
そして<code>dependencies</code>が1つでも<code>===</code>で比較して変更された時だけ<code>valueFn</code>を再評価します。</p>
<p>引数:</p>
<ul>
<li><code>dependencies</code>は変更を検知する対象を格納している配列です。</li>
<li><code>valueFn</code>はレンダリング可能な値を返す関数です。</li>
</ul>
<p><code>guard</code>はデータが変更されるまで高コストの処理を行わないイミュータブルデータパターンに利用することができます。</p>
<pre><code class="language-ts">@customElement('my-element')
class MyElement extends LitElement {

  @property()
  value: string = '';

  render() {
    return html`
      &lt;div&gt;
        ${guard([this.value], () =&gt; calculateSHA(this.value))}
      &lt;/div&gt;`;
  }
}
</code></pre>
<p>上記のケースでは、<code>value</code>プロパティが変更された時のみ高コストの<code>calculateSHA</code>関数を実行します。</p>
<h3 id="live"><a href="#live">live</a></h3>
<p>属性やプロパティの値が(最後のレンダリング時の値ではなく)現行のDOMの値と異なる場合、属性やプロパティに値をセットします。</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {live} from 'lit/directives/live.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">live(value: unknown)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p><a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Attribute_expressions">Attribute expression</a>もしくは<a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Property_expressions">Property expression</a></p>
</td>
</tr>
</tbody>
</table>

<p>属性やプロパティの値を更新するかの判断は、
Litのデフォルトの動作ではエクスプレッションに最後にセットされた値と比較します。
<code>live</code>を使うと現行のDOMの属性やプロパティの値と比較します。
詳しくは<a class="Link" href="https://lit.dev/playground/#sample=examples/directive-live">こちら</a>を見てください。</p>
<p>これはDOMの値がLitの外部から変更される可能性がある場合に役立ちます。
例えば、
<code>&lt;input&gt;</code>要素の<code>value</code>プロパティの値をセットするエクスプレッションが配置され、
この<code>value</code>プロパティはユーザの入力によって編集可能であり、
custom elementの側でもそのプロパティもしくは属性を変更する場合です。</p>
<p>DOM上の値が変化したがエクスプレッションでセットされた値が変化していない場合、
LitはそのDOM上の値が変化したことを検知することができません。DOM上の値はエクスプレッションでセットされている値で上書きされません。
この挙動を変えたい場合(常にエクスプレッションにセットされた値で上書きしたい場合)は<code>live()</code>ディレクティブを使います。</p>
<pre><code class="language-ts">@customElement('my-element')
class MyElement extends LitElement {

  @property()
  data = {value: 'test'};

  render() {
    return html`&lt;input .value=${live(this.data.value)}&gt;`;
  }
}
</code></pre>
<p><code>live()</code>は現行のDOMの値と渡された値を<code>===</code>で比較します。そして、それらが等しい場合は何もしません。
つまり、エクスプレッションが型を変換するような場合は<code>live()</code>を使うべきではありません。
<a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Attribute_expressions">Attribute expression</a>に対する<code>live()</code>には文字列のみを渡してください。そうしないとエクスプレッションは常にレンダリング毎に更新を発生させます。</p>
<h2 id="特殊な値のレンダリング"><a href="#特殊な値のレンダリング">特殊な値のレンダリング</a></h2>
<h3 id="templateContent"><a href="#templateContent">templateContent</a></h3>
<p>Renders the content of a <code>&lt;template&gt;</code> element.</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {templateContent} from 'lit/directives/template-content.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">templateContent(templateElement: HTMLTemplateElement)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p><a class="Link" href="https://japanese-document.github.io/lit/templates-expressions.html#Child_expressions">Child expression</a></p>
</td>
</tr>
</tbody>
</table>

<p>Lit templates are encoded in Javascript, so that they can embed Javascript
expressions that make them dynamic. If you have a static HTML <code>&lt;template&gt;</code> that
you need to include in your Lit template, you can use the <code>templateContent</code>
directive to clone the template content and include it in your Lit template. As
long as the template element reference does not change between renders,
subsequent renders will no-op.</p>
<div class="alert alert-warning">

<p>Note, the template content should be developer-controlled and must not be
created using an untrusted string. Examples of untrusted content include query
string parameters and values from user inputs. Untrusted templates rendered with
this directive could lead to <a class="Link" href="https://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting (XSS)</a> vulnerabilities.</p>
</div>

<pre><code class="language-ts">const templateEl = document.querySelector('template#myContent') as HTMLTemplateElement;

@customElement('my-element')
class MyElement extends LitElement {

  render() {
    return  html`
      Here's some content from a template element:
      ${templateContent(templateEl)}`;
  }
}
</code></pre>
<p>詳しくは<a class="Link" href="https://lit.dev/playground/#sample=examples/directive-template-content">こちら</a>を見てください。</p>
<h3 id="unsafeHTML"><a href="#unsafeHTML">unsafeHTML</a></h3>
<p>Renders a string as HTML rather than text.</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {unsafeHTML} from 'lit/directives/unsafe-html.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">unsafeHTML(value: string | typeof nothing | typeof noChange)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>Child expression</p>
</td>
</tr>
</tbody>
</table>

<p>A key feature of Lit's templating syntax is that only strings originating in
template literals are parsed as HTML. Because template literals can only be
authored in trusted script files, this acts as a natural safeguard against XSS
attacks injecting untrusted HTML. However, there may be cases when HTML not
originating in script files needs to be rendered in a Lit template, for example
trusted HTML content fetched from a database. The <code>unsafeHTML</code> directive will
parse such a string as HTML and render it in a Lit template.</p>
<div class="alert alert-warning">

<p>Note, the string passed to <code>unsafeHTML</code> must be developer-controlled and not
include untrusted content. Examples of untrusted content include query string
parameters and values from user inputs. Untrusted content rendered with this
directive could lead to <a class="Link" href="https://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting (XSS)</a> vulnerabilities.</p>
</div>

<p>{% switchable-sample %}</p>
<pre><code class="language-ts">const markup = '&lt;h3&gt;Some HTML to render.&lt;/h3&gt;';

@customElement('my-element')
class MyElement extends LitElement {

  render() {
    return html`
      Look out, potentially unsafe HTML ahead:
      ${unsafeHTML(markup)}
    `;
  }
}
</code></pre>
<pre><code class="language-js">const markup = '&lt;h3&gt;Some HTML to render.&lt;/h3&gt;';

class MyElement extends LitElement {

  render() {
    return html`
      Look out, potentially unsafe HTML ahead:
      ${unsafeHTML(markup)}
    `;
  }
}
customElements.define('my-element', MyElement);
</code></pre>
<p>{% endswitchable-sample %}</p>
<p>Explore <code>unsafeHTML</code> more in the <a class="Link" href="/playground/#sample=examples/directive-unsafe-html">playground</a>.</p>
<h3 id="unsafeSVG"><a href="#unsafeSVG">unsafeSVG</a></h3>
<p>Renders a string as SVG rather than text.</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {unsafeSVG} from 'lit/directives/unsafe-svg.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">unsafeSVG(value: string | typeof nothing | typeof noChange)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>Child expression</p>
</td>
</tr>
</tbody>
</table>

<p>Similar to with <a class="Link" href="#unsafeHTML"><code>unsafeHTML</code></a>, there may be cases when SVG content
not originating in script files needs to be rendered in a Lit template, for
example trusted SVG content fetched from a database. The <code>unsafeSVG</code> directive
will parse such a string as SVG and render it in a Lit template.</p>
<div class="alert alert-warning">

<p>Note, the string passed to <code>unsafeSVG</code> must be developer-controlled and not
include untrusted content. Examples of untrusted content include query string
parameters and values from user inputs. Untrusted content rendered with this
directive could lead to <a class="Link" href="https://en.wikipedia.org/wiki/Cross-site_scripting">cross-site scripting (XSS)</a> vulnerabilities.</p>
</div>

<p>{% switchable-sample %}</p>
<pre><code class="language-ts">const svg = '&lt;circle cx="50" cy="50" r="40" fill="red" /&gt;';

@customElement('my-element')
class MyElement extends LitElement {

  render() {
    return html`
      Look out, potentially unsafe SVG ahead:
      &lt;svg width="40" height="40" viewBox="0 0 100 100"
        xmlns="http://www.w3.org/2000/svg" version="1.1"&gt;
        ${unsafeSVG(svg)}
      &lt;/svg&gt; `;
  }
}
</code></pre>
<pre><code class="language-js">const svg = '&lt;circle cx="50" cy="50" r="40" fill="red" /&gt;';

class MyElement extends LitElement {

  render() {
    return html`
      Look out, potentially unsafe SVG ahead:
      &lt;svg width="40" height="40" viewBox="0 0 100 100"
        xmlns="http://www.w3.org/2000/svg" version="1.1"&gt;
        ${unsafeSVG(svg)}
      &lt;/svg&gt; `;
  }
}
customElements.define('my-element', MyElement);
</code></pre>
<p>{% endswitchable-sample %}</p>
<p>Explore <code>unsafeSVG</code> more in the <a class="Link" href="/playground/#sample=examples/directive-unsafe-svg">playground</a>.</p>
<h2 id="レンダリングされたDOMの参照"><a href="#レンダリングされたDOMの参照">レンダリングされたDOMの参照</a></h2>
<h3 id="ref"><a href="#ref">ref</a></h3>
<p>Retrieves a reference to an element rendered into the DOM.</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {ref} from 'lit/directives/ref.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">ref(refOrCallback: RefOrCallback)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>Element expression</p>
</td>
</tr>
</tbody>
</table>

<p>Although most DOM manipulation in Lit can be achieved declaratively using
templates, advanced situations may required getting a reference to an element
rendered in the template and manipulating it imperatively. Common examples of
when this may be useful include focusing a form control or calling an imperative
DOM manipulation library on a container element.</p>
<p>When placed on an element in the template, the <code>ref</code> directive will retrieve a
reference to that element once rendered. The element reference may be retrieved
in one of two ways: either by passing a <code>Ref</code> object or by passing a callback.</p>
<p>A <code>Ref</code> object acts as a container for a reference to the element, and can be
created using the <code>createRef</code> helper method found in the <code>ref</code> module. After
rendering, the <code>Ref</code>'s <code>value</code> property will be set to the element, where it
can be accessed in post-render lifecycle like <code>updated</code>.</p>
<p>{% switchable-sample %}</p>
<pre><code class="language-ts">@customElement('my-element')
class MyElement extends LitElement {

  inputRef: Ref&lt;HTMLInputElement&gt; = createRef();

  render() {
    // Passing ref directive a Ref object that will hold the element in .value
    return html`&lt;input ${ref(this.inputRef)}&gt;`;
  }

  firstUpdated() {
    const input = this.inputRef.value!;
    input.focus();
  }
}
</code></pre>
<pre><code class="language-js">class MyElement extends LitElement {

  inputRef = createRef();

  render() {
    // Passing ref directive a Ref object that will hold the element in .value
    return html`&lt;input ${ref(this.inputRef)}&gt;`;
  }

  firstUpdated() {
    const input = this.inputRef.value!;
    input.focus();
  }
}
customElements.define('my-element', MyElement);
</code></pre>
<p>{% endswitchable-sample %}</p>
<p>A ref callback can also be passed to the <code>ref</code> directive. The callback will be
called each time the referenced element changes.  If a ref callback is
rendered to a different element position or is removed in a subsequent render,
it will first be called with <code>undefined</code>, followed by another call with the new
element it was rendered to (if any). Note that in a <code>LitElement</code>, the callback
will be called bound to the host element automatically.</p>
<p>{% switchable-sample %}</p>
<pre><code class="language-ts">@customElement('my-element')
class MyElement extends LitElement {

  render() {
    // Passing ref directive a change callback
    return html`&lt;input ${ref(this.inputChanged)}&gt;`;
  }

  inputChanged(input?: HTMLInputElement) {
    input?.focus();
  }
}
</code></pre>
<pre><code class="language-js">class MyElement extends LitElement {

  render() {
    // Passing ref directive a change callback
    return html`&lt;input ${ref(this.inputChanged)}&gt;`;
  }

  inputChanged(input) {
    input?.focus();
  }
}
customElements.define('my-element', MyElement);
</code></pre>
<p>{% endswitchable-sample %}</p>
<p>Explore <code>ref</code> more in the <a class="Link" href="/playground/#sample=examples/directive-ref">playground</a>.</p>
<h2 id="非同期レンダリング"><a href="#非同期レンダリング">非同期レンダリング</a></h2>
<h3 id="until"><a href="#until">until</a></h3>
<p>Renders placeholder content until one or more promises resolve.</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {until} from 'lit/directives/until.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">until(...values: unknown[])
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>Any expression</p>
</td>
</tr>
</tbody>
</table>

<p>Takes a series of values, including Promises. Values are rendered in priority order,
 with the first argument having the highest priority and the last argument having the
 lowest priority. If a value is a Promise, a lower-priority value will be rendered until it resolves.</p>
<p>The priority of values can be used to create placeholder content for async
data. For example, a Promise with pending content can be the first
(highest-priority) argument, and a non-promise loading indicator template can
be used as the second (lower-priority) argument. The loading indicator
renders immediately, and the primary content will render when the Promise
resolves.</p>
<p>{% switchable-sample %}</p>
<pre><code class="language-ts">@customElement('my-element')
class MyElement extends LitElement {

  @state()
  private content = fetch('./content.txt').then(r =&gt; r.text());

  render() {
    return html`${until(this.content, html`&lt;span&gt;Loading...&lt;/span&gt;`)}`;
  }
}
</code></pre>
<pre><code class="language-js">class MyElement extends LitElement {
  static properties = {
    content: {state: true},
  };

  constructor() {
    super();
    this.content = fetch('./content.txt').then(r =&gt; r.text());
  }

  render() {
    return html`${until(this.content, html`&lt;span&gt;Loading...&lt;/span&gt;`)}`;
  }
}
customElements.define('my-element', MyElement);
</code></pre>
<p>{% endswitchable-sample %}</p>
<p>Explore <code>until</code> more in the <a class="Link" href="/playground/#sample=examples/directive-until">playground</a>.</p>
<h3 id="asyncAppend"><a href="#asyncAppend">asyncAppend</a></h3>
<p>Appends values from an <code>AsyncIterable</code> into the DOM as they are yielded.</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {asyncAppend} from 'lit/directives/async-append.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">asyncAppend(iterable: AsyncIterable)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>Child expression</p>
</td>
</tr>
</tbody>
</table>

<p><code>asyncAppend</code> renders the values of an <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of">async iterable</a>, appending each new value after the previous. Note that async generators also implement the async iterable protocol, and thus can be consumed by <code>asyncAppend</code>.</p>
<p>{% switchable-sample %}</p>
<pre><code class="language-ts">async function *tossCoins(count: number) {
  for (let i=0; i&lt;count; i++) {
    yield Math.random() &gt; 0.5 ? 'Heads' : 'Tails';
    await new Promise((r) =&gt; setTimeout(r, 1000));
  }
}

@customElement('my-element')
class MyElement extends LitElement {

  @state()
  private tosses = tossCoins(10);

  render() {
    return html`
      &lt;ul&gt;${asyncAppend(this.tosses, (v: string) =&gt; html`&lt;li&gt;${v}&lt;/li&gt;`)}&lt;/ul&gt;`;
  }
}
</code></pre>
<pre><code class="language-js">async function *tossCoins(count) {
  for (let i=0; i&lt;count; i++) {
    yield Math.random() &gt; 0.5 ? 'Heads' : 'Tails';
    await new Promise((r) =&gt; setTimeout(r, 1000));
  }
}

class MyElement extends LitElement {
  static properties = {
    tosses: {state: true},
  };

  constructor() {
    super();
    this.tosses = tossCoins(10);
  }

  render() {
    return html`
      &lt;ul&gt;${asyncAppend(this.tosses, (v) =&gt; html`&lt;li&gt;${v}&lt;/li&gt;`)}&lt;/ul&gt;`;
  }
}
customElements.define('my-element', MyElement);
</code></pre>
<p>{% endswitchable-sample %}</p>
<p>Explore <code>asyncAppend</code> more in the <a class="Link" href="/playground/#sample=examples/directive-async-append">playground</a>.</p>
<h3 id="asyncReplace"><a href="#asyncReplace">asyncReplace</a></h3>
<p>Renders the latest value from an <code>AsyncIterable</code> into the DOM as it is yielded.</p>
<table>
<thead><tr><th></th><th></th></tr></thead>
<tbody>
<tr>
<td>Import</td>
<td>

<pre><code class="language-js">import {asyncReplace} from 'lit/directives/async-replace.js';
</code></pre>
</td>
</tr>
<tr>
<td>API</td>
<td>

<pre><code class="language-ts">asyncReplace(iterable: AsyncIterable)
</code></pre>
</td>
</tr>
<tr>
<td>使用可能な場所</td>
<td>

<p>Child expression</p>
</td>
</tr>
</tbody>
</table>

<p>Similar to <a class="Link" href="#asyncappend"><code>asyncAppend</code></a>, <code>asyncReplace</code> renders the values of an <a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of">async iterable</a>, replacing the previous value with each new value.</p>
<p>{% switchable-sample %}</p>
<pre><code class="language-ts">async function *countDown(count: number) {
  while (count &gt; 0) {
    yield count--;
    await new Promise((r) =&gt; setTimeout(r, 1000));
  }
}

@customElement('my-element')
class MyElement extends LitElement {

  @state()
  private timer = countDown(10);

  render() {
    return html`Timer: &lt;span&gt;${asyncReplace(this.timer)}&lt;/span&gt;.`;
  }
}
</code></pre>
<pre><code class="language-js">async function *countDown(count) {
  while (count &gt; 0) {
    yield count--;
    await new Promise((r) =&gt; setTimeout(r, 1000));
  }
}

class MyElement extends LitElement {
  static properties = {
    timer: {state: true},
  };

  constructor() {
    super();
    this.timer = countDown(10);
  }

  render() {
    return html`Timer: &lt;span&gt;${asyncReplace(this.timer)}&lt;/span&gt;.`;
  }
}
customElements.define('my-element', MyElement);
</code></pre>
<p>{% endswitchable-sample %}</p>
<p>Explore <code>asyncReplace</code> more in the <a class="Link" href="/playground/#sample=examples/directive-async-replace">playground</a>.</p>
<hr>
<h2 id="License"><a href="#License">License</a></h2>
<h3 id="Japanese_part"><a href="#Japanese_part">Japanese part</a></h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by-nc/4.0/legalcode">Creative Commons Attribution-NonCommercial 4.0 International Public License</a></p>
<p>Copyright (c) 2022 38elements</p>
<h3 id="Other"><a href="#Other">Other</a></h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by/3.0/deed.en">Creative Commons Attribution 3.0 Unported</a></p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>BSD 3-Clause License</p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ol>
<li><p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p>
</li>
<li><p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p>
</li>
<li><p>Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.</p>
</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </main>
    <div class="right-side"><div class="header-list"><p class="h1"><a href="#ビルトインディレクティブ">ビルトインディレクティブ</a></p>
<p class="h2"><a href="#スタイル">スタイル</a></p>
<p class="h3"><a href="#classMap">classMap</a></p>
<p class="h3"><a href="#styleMap">styleMap</a></p>
<p class="h2"><a href="#繰り返しと条件">繰り返しと条件</a></p>
<p class="h3"><a href="#when">when</a></p>
<p class="h3"><a href="#choose">choose</a></p>
<p class="h3"><a href="#map">map</a></p>
<p class="h3"><a href="#repeat">repeat</a></p>
<p class="h3"><a href="#join">join</a></p>
<p class="h3"><a href="#range">range</a></p>
<p class="h3"><a href="#ifDefined">ifDefined</a></p>
<p class="h2"><a href="#キャッシュと変更の検出">キャッシュと変更の検出</a></p>
<p class="h3"><a href="#cache">cache</a></p>
<p class="h3"><a href="#keyed">keyed</a></p>
<p class="h3"><a href="#guard">guard</a></p>
<p class="h3"><a href="#live">live</a></p>
<p class="h2"><a href="#特殊な値のレンダリング">特殊な値のレンダリング</a></p>
<p class="h3"><a href="#templateContent">templateContent</a></p>
<p class="h3"><a href="#unsafeHTML">unsafeHTML</a></p>
<p class="h3"><a href="#unsafeSVG">unsafeSVG</a></p>
<p class="h2"><a href="#レンダリングされたDOMの参照">レンダリングされたDOMの参照</a></p>
<p class="h3"><a href="#ref">ref</a></p>
<p class="h2"><a href="#非同期レンダリング">非同期レンダリング</a></p>
<p class="h3"><a href="#until">until</a></p>
<p class="h3"><a href="#asyncAppend">asyncAppend</a></p>
<p class="h3"><a href="#asyncReplace">asyncReplace</a></p>
<p class="h2"><a href="#License">License</a></p>
<p class="h3"><a href="#Japanese_part">Japanese part</a></p>
<p class="h3"><a href="#Other">Other</a></p></div></div>
    <footer class="footer markdown-body">
      <a href="/lit">Top</a>
    </footer>
  </body>
</html>