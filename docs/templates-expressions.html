<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <meta name="twitter:card" content="summary" />
    <meta property="og:url" content="https://japanese-document.github.io/lit/templates-expressions.html" />
    <meta property="og:title" content="Expressions" />
    <meta property="og:description" content="Litテンプレートはエクスプレッション(expressions)と呼ばれる動的な値を${...}の形式で埋め込むことができます。エクスプレッションをJavaScriptの式にすることもできます。エクスプレッションはテンプレートが評価されるときに評価されます。そして、その結果はテンプレートのレンダリング結果に影響を与えます。Litコンポーネントはrenderメソッドを実行する毎にこれをします。エクスプレッションはテンプレートの特定の場所にのみ配置することができます。エクスプレッションがどう解釈されるかは、それがある場所で決まります。例えば、要素タグ内にあるエクスプレッションはその要素に影響を与え" />
    <meta property="og:image" content="https://avatars2.githubusercontent.com/u/42838312?s=400" />
    <meta name="theme-color" content="#f1f7fe" />
    <meta name="description" content="Litテンプレートはエクスプレッション(expressions)と呼ばれる動的な値を${...}の形式で埋め込むことができます。エクスプレッションをJavaScriptの式にすることもできます。エクスプレッションはテンプレートが評価されるときに評価されます。そして、その結果はテンプレートのレンダリング結果に影響を与えます。Litコンポーネントはrenderメソッドを実行する毎にこれをします。エクスプレッションはテンプレートの特定の場所にのみ配置することができます。エクスプレッションがどう解釈されるかは、それがある場所で決まります。例えば、要素タグ内にあるエクスプレッションはその要素に影響を与え" />
    <meta name="Hatena::Bookmark" content="nocomment" />
    <title>Expressions</title>
    <link rel="stylesheet" href="/lit/app.css?v=001" type="text/css"  media="all" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-L9VVC74WWF"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-L9VVC74WWF');
    </script>
  </head>
  <body class="container">
    <div class="left-side">
    <nav class="index-menu">
      <details open="">
        <summary>コンポーネント</summary>
        <p><a href="https://japanese-document.github.io/lit/components-defining.html">定義</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-rendering.html">レンダリング</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-properties.html">リアクティブプロパティ</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-styles.html">スタイル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-lifecycle.html">ライフサイクル</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-shadow-dom.html">Shadow DOM</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-events.html">イベント</a></p>
        <p><a href="https://japanese-document.github.io/lit/components-decorators.html">デコレータ</a></p>
      </details>
      <details open="">
        <summary>テンプレート</summary>
        <p><a href="https://japanese-document.github.io/lit/templates-expressions.html">Expressions</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-directives.html">ビルトインディレクティブ</a></p>
        <p><a href="https://japanese-document.github.io/lit/templates-custom-directives.html">カスタムディレクティブ</a></p>
      </details>
      <details open="">
        <summary>組み合わせ</summary>
        <p><a href="https://japanese-document.github.io/lit/composition-controllers.html">リアクティブコントローラ</a></p>
      </details>
      <details open="">
        <summary>API</summary>
        <p><a href="https://japanese-document.github.io/lit/api-LitElement.html">LitElement</a></p>
        <p><a href="https://japanese-document.github.io/lit/api-templates.html">テンプレート</a></p>
      </details>
    </nav></div>
    <main class="main markdown-body">
      <h1 id="Expressions"><a class="anchor" href="#Expressions">#</a>Expressions</h1>
<p>Litテンプレートはエクスプレッション(expressions)と呼ばれる動的な値を<code>${...}</code>の形式で埋め込むことができます。
エクスプレッションをJavaScriptの<a class="Link" href="https://developer.mozilla.org/ja/docs/Web/JavaScript/Guide/Expressions_and_Operators#%E5%BC%8F">式</a>にすることもできます。
エクスプレッションはテンプレートが評価されるときに評価されます。そして、その結果はテンプレートのレンダリング結果に影響を与えます。
Litコンポーネントは<code>render</code>メソッドを実行する毎にこれをします。</p>
<p>エクスプレッションはテンプレートの特定の場所にのみ配置することができます。
エクスプレッションがどう解釈されるかは、それがある場所で決まります。
例えば、要素タグ内にあるエクスプレッションはその要素に影響を与えます。
要素のコンテンツ内にあるエクスプレッションは子Nodeと同じような位置で子Nodeやテキストをレンダリングします。</p>
<p>エクスプレッションの値が有効かどうかはエクスプレッションの位置によって異なります。
一般的に全てのエクスプレッションは文字列や数値などのプリミティブな値を受け入れます。そして、いくつかのエクスプレッションはそれに加えていくつかの型が使用可能です。
それに加えて、全てのエクスプレッションはディレクティブを受け入れることができます。
ディレクティブはエクスプレッションはの処理を変更してレンダリングする特別な関数です。
詳しくは<a class="Link" href="https://lit.dev/docs/templates/custom-directives/">カスタムディレクティブ</a>を見てください。</p>
<p>以下に各エクスプレッションタイプのクイックリファレンスと詳しい説明へのリンクを記載します。</p>
<ul>
<li><a class="Link" href="#Child_expressions">Child nodes</a></li>
</ul>
<pre><code class="language-js">html`
&lt;h1&gt;Hello ${name}&lt;/h1&gt;
&lt;ul&gt;
  ${listItems}
&lt;/ul&gt;`
</code></pre>
<ul>
<li><a class="Link" href="#Attribute_expressions">Attributes</a></li>
</ul>
<pre><code class="language-js">html`&lt;div class=${highlightClass}&gt;&lt;/div&gt;`
</code></pre>
<ul>
<li><a class="Link" href="#Boolean_attribute_expressions">Boolean Attributes</a></li>
</ul>
<pre><code class="language-js">html`&lt;div ?hidden=${!show}&gt;&lt;/div&gt;`
</code></pre>
<ul>
<li><a class="Link" href="#Property_expressions">Properties</a></li>
</ul>
<pre><code class="language-js">html`&lt;input .value=${value}&gt;`
</code></pre>
<ul>
<li><a class="Link" href="#Event_listener_expressions">Event listeners</a></li>
</ul>
<pre><code class="language-js">html`&lt;button @click=${this._clickHandler}&gt;Go&lt;/button&gt;`
</code></pre>
<ul>
<li><a class="Link" href="#Element_expressions">Element directives</a></li>
</ul>
<pre><code class="language-js">html`&lt;input ${ref(inputRef)}&gt;`
</code></pre>
<p>以下のセクションで各エクスプレッションの詳しい説明をします。
テンプレートの構造のより詳しい説明は<a class="Link" href="#Well-formed_HTML">Well-formed HTML</a>と<a class="Link" href="#有効なエクスプレッションの位置">有効なエクスプレッションの位置</a>を見てください。</p>
<h2 id="Child_expressions"><a class="anchor" href="#Child_expressions">#</a>Child expressions</h2>
<p>要素のタグの始まりと終わりの間にあるエクスプレッションは要素に子Nodeを加えます。例えば、</p>
<pre><code class="language-js">html`&lt;p&gt;Hello, ${name}&lt;/p&gt;`
</code></pre>
<p>もしくは、</p>
<pre><code class="language-js">html`&lt;main&gt;${bodyText}&lt;/main&gt;`
</code></pre>
<p>この位置にあるエクスプレッションは以下の値を受け入れることができます。</p>
<ul>
<li>string、number、boolean等のプリミティブ値</li>
<li><code>html</code>関数で生成される<code>TemplateResult</code>オブジェクト</li>
<li><code>svg</code>関数で生成される<code>SVGTemplateResult</code>オブジェクト</li>
<li>DOM Nodes</li>
<li>センチネル値(<a class="Link" href="https://japanese-document.github.io/lit/api-templates.html#nothing__symbol"><code>nothing</code></a>と<a class="Link" href="https://lit.dev/docs/emplates/custom-directives/#signaling-no-change"><code>noChange</code></a>)</li>
<li>使用可能な型の配列もしくはiterables</li>
</ul>
<h3 id="プリミティブ値"><a class="anchor" href="#プリミティブ値">#</a>プリミティブ値</h3>
<p>Litはほとんどすべての<a class="Link" href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive">プリミティブ値</a>をレンダリングすることができます。 
そして、テキストコンテントに挿入される場合はそれらを文字列に変換します。</p>
<p><code>5</code>のような数値は<code>'5'</code>の文字列にレンダリングされます。
Bigintも同様に扱われます。</p>
<p>booleanは<code>true</code>は<code>'true'</code>にレンダリングされます。<code>false</code>は<code>'false'</code>にレンダリングされます。でも、ふつうはbooleanでこういうことはしません。
通常、booleanは条件として使われるます。詳しくは<a class="Link" href="https://lit.dev/docs/templates/conditionals/">Conditionals</a>見てください。</p>
<p>空文字(<code>''</code>)、<code>null</code>、<code>undefined</code>は特別な意味を持ちます。
そして、それらは何もレンダリングしません。
詳しくは<a class="Link" href="#子コンテンツの削除">子コンテンツの削除</a>を見てください。</p>
<p><code>Symbol</code>は文字列に変換されません。child expressionに置かれた場合、例外が発生します。</p>
<h3 id="センチネル値"><a class="anchor" href="#センチネル値">#</a>センチネル値</h3>
<p>Litはchild expressionに使うことができるいくつかの特別なセンチネル値を提供します。</p>
<p><code>noChange</code>センチネル値はエクスプレッションの既存の値を変更しません。
これは通常、カスタムディレクティブで使われます。
詳しくは<a class="Link" href="https://lit.dev/docs/templates/custom-directives/#signaling-no-change">Signaling no change</a>を見てください。</p>
<p><code>nothing</code>センチネルは何もレンダリングしません。
詳しくは<a class="Link" href="#子コンテンツの削除">子コンテンツの削除</a>を見てください。</p>
<h3 id="Templates"><a class="anchor" href="#Templates">#</a>Templates</h3>
<p>エクスプレッション内に<code>TemplateResult</code>を返すエクスプレッションを配置することができるので、テンプレートをネストしたり組み合わせたりすることができます。</p>
<pre><code class="language-js">const nav = html`&lt;nav&gt;...&lt;/nav&gt;`;
const page = html`
  ${nav}
  &lt;main&gt;...&lt;/main&gt;
`;
</code></pre>
<p>これは素のJavaScriptを使って条件分岐のあるテンプレートや繰り返しがあるテンプレート等を生成することができることを意味します。</p>
<pre><code class="language-js">html`
  ${this.user.isloggedIn
      ? html`Welcome ${this.user.name}`
      : html`Please log in`
  }
`;
</code></pre>
<p>条件分岐のあるテンプレートに関する詳しい説明は<a class="Link" href="https://lit.dev/docs/templates/conditionals/">Conditionals</a>にあります。</p>
<p>繰り返しがあるテンプレートに関する詳しい説明は<a class="Link" href="https://lit.dev/docs/templates/lists/">Lists</a>にあります。</p>
<h3 id="DOM_nodes"><a class="anchor" href="#DOM_nodes">#</a>DOM nodes</h3>
<p>DOM Nodeはchild expressionに渡すことができます。
通常、DOM Nodeは<code>html</code>を使ったテンプレートを記述することでレンダリングされます。
しかし、必要な時は下記のようにDOM Nodeを直接レンダリングすることができます。
この時、現在の親Nodeから削除されて、NodeはDOMツリーに取り付けられます。</p>
<pre><code class="language-js">const div = document.createElement('div');
const page = html`
  ${div}
  &lt;p&gt;This is some text&lt;/p&gt;
`;
</code></pre>
<h3 id="使用可能な型の配列もしくはiterables"><a class="anchor" href="#使用可能な型の配列もしくはiterables">#</a>使用可能な型の配列もしくはiterables</h3>
<p>エクスプレッションは使用可能な型を格納する配列、iterable、それらの組み合わせを返すことができます。
つまり、<code>Array.map()</code>を使って繰り返し表現を生成することができます。
詳しくは<a class="Link" href="https://lit.dev/docs/templates/lists/">リスト</a>を見てください。</p>
<h3 id="子コンテンツの削除"><a class="anchor" href="#子コンテンツの削除">#</a>子コンテンツの削除</h3>
<p><code>null</code>、<code>undefined</code>、空文字列(<code>''</code>)、Litの<a class="Link" href="https://japanese-document.github.io/lit/api-templates.html#nothing__symbol">nothing</a>センチネル値は、1つ前のレンダリングされたコンテンツを削除します。そして、Nodeをレンダリングしません。</p>
<p>子コンテンツの配置もしくは削除はよく条件分岐によって行われます。
詳しくは<a class="Link" href="https://lit.dev/docs/templates/conditionals/#conditionally-rendering-nothing">Conditionally rendering nothing</a>を見てください。</p>
<p>フォールバックコンテンツを持つ<code>slot</code>に対応するコンテンツがない場合、フォールバックコンテンツがレンダリングされます。
詳しくは<a class="Link" href="https://japanese-document.github.io/lit/components-shadow-dom.html#デフォルトでslotに適用されるコンテンツを指定する">fallback content</a>を見てください。</p>
<h2 id="Attribute_expressions"><a class="anchor" href="#Attribute_expressions">#</a>Attribute expressions</h2>
<p>エクスプレッションを使って要素の属性やプロパティをセットすることができます。</p>
<p>デフォルトでは属性の値にエクスプレッションがあるとそれが属性の値になります。</p>
<pre><code class="language-js">html`&lt;div class=${this.textClass}&gt;Stylish text.&lt;/div&gt;`;
</code></pre>
<p>属性の値は必ず文字列なので、エクスプレッションは文字列に変換することができる値を返す必要があります。</p>
<p>上記のようにエクスプレッションが属性の値全体の場合、属性の値を<code>"</code>で囲むことを省略できます。
下記のようにエクスプレッションが属性の値の一部の場合、属性の値を<code>"</code>で囲む必要があります。</p>
<pre><code class="language-js">html`&lt;img src="/images/${this.image}"&gt;`;
</code></pre>
<p>一部のプリミティブ値は属性にセットされると特殊な評価をされます。
Booleanは文字列に変換されます。例えば、<code>false</code>は<code>'false'</code>に変換されます。
<code>undefined</code>と<code>null</code>は空文字(<code>""</code>)としてレンダリングされます。</p>
<h3 id="Boolean_attributes"><a class="anchor" href="#Boolean_attributes">#</a>Boolean attributes</h3>
<p>下記のように属性名の先頭に<code>?</code>を付けるとboolean attributesになります。
エクスプレッションにtrueになる値がセットされると属性は配置されます。
falseになる値がセットされると属性は削除されます。</p>
<pre><code class="language-js">html`&lt;div ?hidden=${!this.showAdditional}&gt;This text may be hidden.&lt;/div&gt;`;
</code></pre>
<h3 id="属性の削除"><a class="anchor" href="#属性の削除">#</a>属性の削除</h3>
<p><code>disabled</code>や<code>hidden</code>は<a class="Link" href="#Boolean_attributes">boolean attributes</a>で対応できます。しかし、属性の値を構成するデータの一部が欠けている場合に属性を削除したい場合があります。</p>
<p>下記の例について考えてみましょう。</p>
<pre><code class="language-js">html`&lt;img src="/images/${this.imagePath}/${this.imageFile}"&gt;`;
</code></pre>
<p><code>this.imagePath</code>もしくは<code>this.imageFile</code>が定義されていない場合に<code>src</code>属性を削除したいとします。</p>
<pre><code class="language-js">html`&lt;img src="/images/${this.imagePath ?? nothing}/${this.imageFile ?? nothing}"&gt;`;
</code></pre>
<p>その場合は上記のように<a class="Link" href="https://japanese-document.github.io/lit/api-templates.html#nothing__symbol">nothing</a>を使います。
<code>nothing</code>が存在するとその属性は削除されます。
<code>??</code>は<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing_operator">nullish coalescing operator</a>です。
これは左側の値が<code>null</code>もしくは<code>undefined</code>の場合、右側の値を返します。</p>
<p><a class="Link" href="https://lit.dev/docs/api/directives/#ifDefined">ifDefined</a>ディレクティブは<code>value ?? nothing</code>と等価です。</p>
<pre><code class="language-js">html`&lt;img src="/images/${ifDefined(this.imagePath)}/${ifDefined(this.imageFile)}"&gt;`;
</code></pre>
<p>エクスプレッションの値が<code>false</code>や空文字(<code>''</code>)の場合に属性を削除したい場合は以下のようにします。</p>
<pre><code class="language-js">html`&lt;button aria-label="${this.ariaLabel || nothing}"&gt;&lt;/button&gt;`
</code></pre>
<h2 id="Property_expressions"><a class="anchor" href="#Property_expressions">#</a>Property expressions</h2>
<p>プロパティ名の先頭に<code>.</code>を付けるとプロパティにJavaScriptの値ままセットすることができます。</p>
<pre><code class="language-js">html`&lt;input .value=${this.itemCount}&gt;`;
</code></pre>
<p>この構文を使うと子コンポーネントに複雑なデータを渡すことができます。
下記の例では、<code>listItems</code>プロパティを持つ<code>my-list</code>コンポーネントにオブジェクトの配列を渡すことができます。</p>
<pre><code class="language-js">html`&lt;my-list .listItems=${this.items}&gt;&lt;/my-list&gt;`;
</code></pre>
<p>この例ではプロパティ名に<code>listItems</code>のように大文字と小文字が混在している点に注意してください。
HTMLは大文字と小文字を区別しませんが、Litはテンプレートを処理する際にプロパティ名の大文字と小文字を区別します。</p>
<p>コンポーネントのプロパティに関する詳しい情報は<a class="Link" href="https://japanese-document.github.io/lit/components-properties.html">リアクティブプロパティ</a>を見てください。</p>
<h2 id="Event_listener_expressions"><a class="anchor" href="#Event_listener_expressions">#</a>Event listener expressions</h2>
<p>イベント名の先頭に<code>@</code>をつけることで、
テンプレートで宣言的にイベントリスナを設定することができます。</p>
<pre><code class="language-js">html`&lt;button @click=${this.clickHandler}&gt;Click Me!&lt;/button&gt;`;
</code></pre>
<p>これはbutton要素で<code>addEventListener('click', this.clickHandler)</code>を実行することに似ています。</p>
<p>設定するイベントリスナは素の関数もしくは<code>handleEvent</code>メソッドを持つオブジェクトです。
それら関数は<a class="Link" href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener">addEventListener</a>の第1引数と同じです。</p>
<p>Litコンポーネントではコンポーネントはイベントリスナに自動的にバインド(bind)されます。
イベントリスナ内の<code>this</code>はコンポーネントインスタンスを参照します。</p>
<pre><code class="language-js">clickHandler() {
  this.clickCount++;
}
</code></pre>
<p>コンポーネントイベントに関する詳しい情報は<a class="Link" href="https://lit.dev/docs/components/events/">イベント</a>を見てください。</p>
<h2 id="Element_expressions"><a class="anchor" href="#Element_expressions">#</a>Element expressions</h2>
<p>Element expressionsで要素インスタンスにアクセスすることができます。</p>
<pre><code class="language-js">html`&lt;div ${myDirective()}&gt;&lt;/div&gt;`
</code></pre>
<p>Element expressionsには<a class="Link" href="https://lit.dev/docs/templates/directives/">ディレクティブ</a>のみ渡すことができます。
それ以外の値が渡された場合は無視されます。</p>
<p>Element expressionで使うことができるビルドインディレクティブの1つに<code>ref</code>ディレクティブがあります。
これはレンダリングされた要素の参照を取得することに使います。</p>
<pre><code class="language-js">html`&lt;button ${ref(this.myRef)}`;
</code></pre>
<p>詳しくは<a class="Link" href="https://lit.dev/docs/templates/directives/#ref">ref</a>を見てください。</p>
<h2 id="Well-formed_HTML"><a class="anchor" href="#Well-formed_HTML">#</a>Well-formed HTML</h2>
<p>Litテンプレートはwell-formed HTMLである必要があります。
テンプレートは値が挿入される前にブラウザのビルドインHTMLパーサーでパースされます。
有効なテンプレートであるためには下記のルールに従う必要があります。</p>
<ul>
<li><p>テンプレートは全てのエクスプレッションが空白になった時にwell-formed HTMLである必要があります。</p>
</li>
<li><p>複数のテキストや要素をテンプレートのトップレベルに配置してもよいです。</p>
</li>
<li><p>テンプレートにHTMLパーサーで補完される閉じてない要素を記述してはいけません。</p>
<pre><code class="language-js">// HTMLパーサーは"Some text"の後に&lt;/div&gt;を追加します。
const template1 = html`&lt;div class="broken-div"&gt;Some text`;
// これを以下に追加すると壊れたHTMLになります。
const template2 = html`${template1} more text. &lt;/div&gt;`;
</code></pre>
</li>
</ul>
<h2 id="有効なエクスプレッションの位置"><a class="anchor" href="#有効なエクスプレッションの位置">#</a>有効なエクスプレッションの位置</h2>
<p>エクスプレッションは属性の値もしくは子コンテンツの位置に置く必要があります。</p>
<pre><code class="language-html">&lt;!-- 属性の値 --&gt;
&lt;div label=${label}&gt;&lt;/div&gt;
&lt;button ?disabled=${isDisabled}&gt;Click me!&lt;/button&gt;
&lt;input .value=${currentValue}&gt;
&lt;button @click=${this.handleClick()}&gt;

&lt;!-- 子コンテンツ --&gt;
&lt;div&gt;${textContent}&lt;/div&gt;
</code></pre>
<p>Element expressionsは開始タグのタグ名の後に置く必要があります。</p>
<pre><code class="language-html">&lt;div ${ref(elementReference)}&gt;&lt;/div&gt;
</code></pre>
<h3 id="無効なエクスプレッションの位置"><a class="anchor" href="#無効なエクスプレッションの位置">#</a>無効なエクスプレッションの位置</h3>
<p>通常、エクスプレッションを下記の位置に配置してはいけません。</p>
<ul>
<li><p>Litはタグ名や属性名の位置に動的に変化する値を配置することはできません。developmentモードでエラーが発生します。</p>
<pre><code class="language-html">&lt;!-- エラー --&gt;
&lt;${tagName}&gt;&lt;/${tagName}&gt;

&lt;!-- エラー --&gt;
&lt;div ${attrName}=true&gt;&lt;/div&gt;
</code></pre>
</li>
<li><p><code>&lt;tempalte&gt;</code>の子コンテンツ(template要素のattribute expressionsは可能)</p>
<pre><code class="language-html">&lt;!-- エラー --&gt;
&lt;template&gt;${content}&lt;/template&gt;

&lt;!-- OK --&gt;
&lt;template id="${attrValue}"&gt;static content ok&lt;/template&gt;
</code></pre>
</li>
<li><p><code>&lt;textarea&gt;</code>の子コンテンツ(textarea要素のattribute expressionsは可能)
Litはtextareaの子コンテンツをレンダリングすることはできますが、
textareaを編集するとLitが動的に更新するために使っているDOMへの参照が壊れます。
Litはdevelopmentモードで警告を出します。
代わりに<code>.value</code>プロパティをtextarea要素に付与します。</p>
<pre><code class="language-html">&lt;!-- 注意 --&gt;
&lt;textarea&gt;${content}&lt;/textarea&gt;

&lt;!-- OK --&gt;
&lt;textarea .value=${content}&gt;&lt;/textarea&gt;

&lt;!-- OK --&gt;
&lt;textarea id="${attrValue}"&gt;static content ok&lt;/textarea&gt;
</code></pre>
</li>
<li><p><code>contenteditable</code>属性を持つ要素の子コンテンツ(要素のattribute expressionsは可能)
代わりに<code>.innerText</code>プロパティを要素に付与します。</p>
<pre><code class="language-html">&lt;!-- 注意 --&gt;
&lt;div contenteditable&gt;${content}&lt;/div&gt;

&lt;!-- OK --&gt;
&lt;div contenteditable .innerText=${content}&gt;&lt;/div&gt;

&lt;!-- OK --&gt;
&lt;div contenteditable id="${attrValue}"&gt;static content ok&lt;/div&gt;
</code></pre>
</li>
<li><p>コメントの内側。
Litはコメント内のエクスプレッションをLit token string(例: <code>lit$6916837264$</code>)の形式でレンダリングします。
これによって他のエクスプレッションは壊れません。
開発時にエクスプレッションをコメントアウトしても安全です。</p>
<pre><code class="language-html">&lt;!-- will not update: ${value} --&gt;
</code></pre>
</li>
<li><p><a class="Link" href="https://github.com/webcomponents/polyfills/tree/master/packages/shadycss">ShadyCSS polyfill</a>を使っているときのstyle要素の内側。</p>
</li>
</ul>
<p>上記の無効なエクスプレッションは<a class="Link" href="#Static_expressions">Static expressions</a>を使用した場合、有効になります。
ただし、それは非効率なのでパフォーマンスが重要な場面で使用しないでください。</p>
<h2 id="Static_expressions"><a class="anchor" href="#Static_expressions">#</a>Static expressions</h2>
<p>LitがテンプレートをHTMLとして処理する前に、static expressionsはテンプレートに埋め込まれる特別な値を返します。
それはテンプレートの静的なHTMLの一部になるので、
タグ名や属性名のような普通は配置することができない位置にエクスプレッションを配置することができます。</p>
<p>static expressionsを使うには、<code>static-html</code>モジュールから特別なバージョンの<code>html</code>もしくは<code>svg</code>をimportする必要があります。</p>
<pre><code class="language-ts">import {html, literal} from 'lit/static-html.js';
</code></pre>
<p><code>static-html</code>モジュールはstatic expressionsをサポートする<code>html</code>関数と<code>svg</code>関数を提供します。それらは<code>lit</code>モジュールが提供する通常版の代わりに使います。
<code>literal</code>タグ関数を使ってstatic expressionを作成します。</p>
<p>static expressionは低頻度で変更されるテンプレートの箇所や通常版ではできないテンプレートのカスタマイズに使います。
詳しくは<a class="Link" href="#有効なエクスプレッションの位置">有効なエクスプレッションの位置</a>を見てください。
例えば、<code>my-button</code>コンポーネントでは<code>&lt;button&gt;</code>タグをレンダリングしますが、そのサブクラスではそこを<code>&lt;a&gt;</code>タグに置き換えたい場合です。
このHTMLタグは変更されません。更に通常のエクスプレッションではタグ名の位置に配置することはできません。
だから、これはstatic expressionsに適したユースケースです。</p>
<pre><code class="language-ts">import {LitElement} from 'lit';
import {customElement, property} from 'lit/decorators.js';
import {html, literal} from 'lit/static-html.js';

@customElement('my-button')
class MyButton extends LitElement {
  tag = literal`button`;
  activeAttribute = literal`active`;
  @property() caption = 'Hello static';
  @property({type: Boolean}) active = false;

  render() {
    return html`
      &lt;${this.tag} ${this.activeAttribute}?=${this.active}&gt;
        &lt;p&gt;${this.caption}&lt;/p&gt;
      &lt;/${this.tag}&gt;`;
  }
}
</code></pre>
<pre><code class="language-ts">@customElement('my-anchor')
class MyAnchor extends MyButton {
  tag = literal`a`;
}
</code></pre>
<p>static expressionsの値を変更することは高いコストを生じさせます。
その変更はテンプレートの再パースを引き起こし、変更したstatic expressionsの値ごとの結果をメモリーに保存するため、
<code>literal</code>の値を使っているエクスプレッションを高頻度で変更するべきではありません。</p>
<p>上記の例では
<code>this.caption</code>もしくは<code>this.active</code>が変更された場合は
影響を受けるエクスプレッションを変更するのでテンプレートを効率的に更新することができます。
(テンプレートに存在するエクスプレッションの変更と見なされる)
しかし、<code>this.tag</code>もしくは<code>this.activeAttribute</code>が変更された場合、
それらは<code>literal</code>が付いているのでテンプレート内で静的な値と見なされます。
だから、テンプレート全体が別の新しいテンプレートに置き換わったと見なされます。
それでDOM全体が再レンダリングされるので、この更新は非効率です。
それに加えて、エクスプレッションに渡される<code>literal</code>の値を変更することはメモリーの使用量を増加させます。
再レンダリングのパフォーマンスを改善するためにテンプレートの構造ごとにそれをメモリーにキャッシュします。</p>
<p>これらの理由により、
なるべく<code>literal</code>を使わないことを推奨します。
そして、リアクティブプロパティは値が変更されることを前提としているのでリアクティブプロパティに<code>literal</code>が付いた値を保存しないことを推奨します。</p>
<h3 id="テンプレートの構造"><a class="anchor" href="#テンプレートの構造">#</a>テンプレートの構造</h3>
<p><code>literal</code>の値が埋め込まれた後のテンプレートは普通のLitテンプレートと同じようにWell-formed_HTMLである必要があります。
そうしないと、テンプレート内の動的なエクスプレッションが適切に機能しない可能性があります。
詳しくは<a class="Link" href="#Well-formed_HTML">Well-formed HTML</a>を見てください。</p>
<h3 id="Non-literal_statics"><a class="anchor" href="#Non-literal_statics">#</a>Non-literal statics</h3>
<p>稀に、動的な値を静的なHTMLとしてテンプレートに埋め込みたい場合があります。その場合は<code>literal</code>を使うことができません。
代わりに<code>unsafeStatic()</code>ディレクティブを使います。</p>
<pre><code class="language-ts">import {html, unsafeStatic} from 'lit/static-html.js';
</code></pre>
<p>信頼できるコンテンツのみ<code>unsafeStatic()</code>に渡します。
<code>unsafeStatic()</code>の<code>unsafe</code>という単語に注目してください。
サニタイズなしに直接HTMLとして解釈されるので
<code>unsafeStatic()</code>に渡される文字列に信頼できない文字列を渡してはいけません。
信頼できない文字列の例はクエリーパラメータやユーザの入力から得た文字列です。
このディレクティブでレンダリングされた信頼できない文字列によって<a class="Link" href="https://en.wikipedia.org/wiki/Cross-site_scripting">クロスサイトスクリプティング(XSS)</a>が引き起こされる可能性があります。</p>
<pre><code class="language-ts">@customElement('my-button')
class MyButton extends LitElement {
  @property() caption = 'Hello static';
  @property({type: Boolean}) active = false;

  render() {
    // これらは信頼できる文字列でなければならない、そうでなければXSSの脆弱性があります。
    const tag = getTagName();
    const activeAttribute = getActiveAttribute();
    return html`
      &lt;${unsafeStatic(tag)} ${unsafeStatic(activeAttribute)}?=${this.active}&gt;
        &lt;p&gt;${this.caption}&lt;/p&gt;
      &lt;/${unsafeStatic(tag)}&gt;`;
  }
}
</code></pre>
<p><code>unsafeStatic</code>を使う際は<code>literal</code>と同じ注意事項があります。
値の変更はテンプレートのパースとメモリーへのキャッシュを引き起こすので、頻繁に変更するべきではありません。</p>
<hr>
<h2 id="License"><a class="anchor" href="#License">#</a>License</h2>
<h3 id="Japanese_part"><a class="anchor" href="#Japanese_part">#</a>Japanese part</h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by-nc/4.0/legalcode">Creative Commons Attribution-NonCommercial 4.0 International Public License</a></p>
<p>Copyright (c) 2022 38elements</p>
<h3 id="Other"><a class="anchor" href="#Other">#</a>Other</h3>
<p><a class="Link" href="https://creativecommons.org/licenses/by/3.0/deed.en">Creative Commons Attribution 3.0 Unported</a></p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>BSD 3-Clause License</p>
<p>Copyright (c) 2020 Google LLC. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>
<ol>
<li><p>Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.</p>
</li>
<li><p>Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.</p>
</li>
<li><p>Neither the name of the copyright holder nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.</p>
</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

    </main>
    <div class="right-side"><nav class="header-list"><p class="h1"><a href="#Expressions">Expressions</a></p>
<p class="h2"><a href="#Child_expressions">Child expressions</a></p>
<p class="h3"><a href="#プリミティブ値">プリミティブ値</a></p>
<p class="h3"><a href="#センチネル値">センチネル値</a></p>
<p class="h3"><a href="#Templates">Templates</a></p>
<p class="h3"><a href="#DOM_nodes">DOM nodes</a></p>
<p class="h3"><a href="#使用可能な型の配列もしくはiterables">使用可能な型の配列もしくはiterables</a></p>
<p class="h3"><a href="#子コンテンツの削除">子コンテンツの削除</a></p>
<p class="h2"><a href="#Attribute_expressions">Attribute expressions</a></p>
<p class="h3"><a href="#Boolean_attributes">Boolean attributes</a></p>
<p class="h3"><a href="#属性の削除">属性の削除</a></p>
<p class="h2"><a href="#Property_expressions">Property expressions</a></p>
<p class="h2"><a href="#Event_listener_expressions">Event listener expressions</a></p>
<p class="h2"><a href="#Element_expressions">Element expressions</a></p>
<p class="h2"><a href="#Well-formed_HTML">Well-formed HTML</a></p>
<p class="h2"><a href="#有効なエクスプレッションの位置">有効なエクスプレッションの位置</a></p>
<p class="h3"><a href="#無効なエクスプレッションの位置">無効なエクスプレッションの位置</a></p>
<p class="h2"><a href="#Static_expressions">Static expressions</a></p>
<p class="h3"><a href="#テンプレートの構造">テンプレートの構造</a></p>
<p class="h3"><a href="#Non-literal_statics">Non-literal statics</a></p>
<p class="h2"><a href="#License">License</a></p>
<p class="h3"><a href="#Japanese_part">Japanese part</a></p>
<p class="h3"><a href="#Other">Other</a></p></nav></div>
    <footer class="footer markdown-body">
      <a href="/lit">Top</a>
    </footer>
  </body>
</html>